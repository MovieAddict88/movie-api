<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CineMax API Manager with TMDB Integration</title>
    <style>
        :root {
            --primary: #3498db;
            --success: #2ecc71;
            --warning: #f39c12;
            --danger: #e74c3c;
            --dark: #2c3e50;
            --light: #ecf0f1;
            --gray: #95a5a6;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f4f7f9;
            color: #333;
            line-height: 1.6;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #2c3e50, #4a6491);
            color: white;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            max-width: 800px;
            margin: 0 auto;
        }
        
        .card {
            background-color: #ffffff;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
            padding: 25px;
            margin-bottom: 25px;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.12);
        }
        
        .card h2 {
            color: var(--dark);
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--primary);
            display: flex;
            align-items: center;
        }
        
        .card h2 i {
            margin-right: 10px;
            font-size: 1.5rem;
        }
        
        .load-section {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .load-file, .load-text {
            flex: 1;
        }
        
        .auto-gen-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }
        
        .auto-gen-toggle label {
            margin: 0;
            font-weight: 600;
            color: var(--dark);
        }
        
        .auto-gen-toggle input[type="checkbox"] {
            width: 20px;
            height: 20px;
            accent-color: var(--primary);
        }
        
        .auto-gen-toggle .help-text {
            font-size: 0.9rem;
            color: var(--gray);
            margin-left: 10px;
        }
        
        .btn-secondary {
            background-color: var(--gray);
            color: white;
            border: none;
            border-radius: 6px;
            padding: 8px 16px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background-color 0.3s ease;
        }
        
        .btn-secondary:hover {
            background-color: #7f8c8d;
        }
        
        .info-section {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid var(--primary);
        }
        
        .info-toggle {
            cursor: pointer;
            user-select: none;
            font-weight: 600;
            color: var(--primary);
        }
        
        .info-content {
            margin-top: 10px;
            display: none;
            font-size: 0.9rem;
            line-height: 1.6;
        }
        
        .info-content.show {
            display: block;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--dark);
        }
        
        input, select, textarea, button {
            border-radius: 6px;
            font-family: inherit;
        }
        
        input[type="file"], input[type="text"], select, textarea {
            width: 100%;
            padding: 12px 15px;
            border: 1px solid #dce4ec;
            background-color: #f8f9fa;
            transition: border-color 0.3s, box-shadow 0.3s;
        }
        
        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
        }
        
        textarea {
            resize: vertical;
            min-height: 120px;
        }
        
        button {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: background-color 0.3s, transform 0.2s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        
        button:hover {
            background-color: #2980b9;
            transform: translateY(-2px);
        }
        
        button i {
            margin-right: 8px;
        }
        
        #loadTextButton {
            margin-top: 15px;
            background-color: var(--success);
        }
        
        #loadTextButton:hover {
            background-color: #27ae60;
        }
        
        .editor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .entry-filters {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .filter-btn {
            background-color: var(--light);
            color: var(--dark);
            padding: 8px 15px;
            font-size: 14px;
        }
        
        .filter-btn.active {
            background-color: var(--primary);
            color: white;
        }
        
        #entryList {
            margin-top: 15px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
        }
        
        .entry-item {
            background-color: #ffffff;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #e0e0e0;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            display: flex;
            flex-direction: column;
            transition: transform 0.3s, box-shadow 0.3s;
        }
        
        .entry-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
        }
        
        .entry-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .entry-type {
            font-size: 0.8rem;
            padding: 3px 8px;
            border-radius: 12px;
            font-weight: 600;
        }
        
        .type-movie {
            background-color: #e1f0fa;
            color: #2980b9;
        }
        
        .type-series {
            background-color: #e8f5e9;
            color: #27ae60;
        }
        
        .type-channel {
            background-color: #fdebd0;
            color: #e67e22;
        }
        
        .entry-item-title {
            font-weight: 600;
            font-size: 1.1rem;
            margin-bottom: 8px;
        }
        
        .entry-item-meta {
            color: var(--gray);
            font-size: 0.9rem;
            margin-bottom: 10px;
        }
        
        .entry-item-actions {
            display: flex;
            gap: 8px;
            margin-top: auto;
        }
        
        .entry-item-actions button {
            flex: 1;
            padding: 8px 12px;
            font-size: 14px;
        }
        
        .edit-btn {
            background-color: var(--warning);
        }
        
        .edit-btn:hover {
            background-color: #e67e22;
        }
        
        .delete-btn {
            background-color: var(--danger);
        }
        
        .delete-btn:hover {
            background-color: #c0392b;
        }
        
        .save-section {
            text-align: center;
            padding: 20px;
        }
        
        #saveButton {
            background-color: var(--success);
            padding: 15px 30px;
            font-size: 1.1rem;
        }
        
        #saveButton:hover {
            background-color: #27ae60;
        }
        
        /* Modal styles */
        .modal {
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }
        
        .modal.active {
            opacity: 1;
            visibility: visible;
        }
        
        .modal-content {
            background-color: #fefefe;
            padding: 30px;
            border-radius: 12px;
            width: 90%;
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 5px 25px rgba(0,0,0,0.3);
            position: relative;
            transform: translateY(-20px);
            transition: transform 0.3s ease-out;
        }
        
        .modal.active .modal-content {
            transform: translateY(0);
        }
        
        .close-button {
            color: #aaa;
            position: absolute;
            top: 15px;
            right: 20px;
            font-size: 32px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.3s;
        }
        
        .close-button:hover,
        .close-button:focus {
            color: black;
            text-decoration: none;
        }
        
        /* Category Tabs */
        .category-tabs {
            display: flex;
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 5px;
            margin-bottom: 20px;
            box-shadow: inset 0 -2px 5px rgba(0,0,0,0.05);
        }
        
        .tab-btn {
            flex: 1;
            padding: 12px 20px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            color: var(--gray);
            border-radius: 6px;
            transition: all 0.3s;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .tab-btn i {
            margin-right: 8px;
        }
        
        .tab-btn.active {
            background-color: white;
            color: var(--primary);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .category-content {
            display: none;
            padding: 15px 0;
        }
        
        .category-content.active {
            display: block;
            animation: fadeIn 0.4s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .form-row {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .form-group {
            flex: 1;
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 8px;
        }
        
        .tmdb-group {
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }
        
        #fetchTMDbButton, #fetchSeriesTMDbButton {
            background-color: var(--success);
            flex-shrink: 0;
            padding: 12px 15px;
        }
        
        #fetchTMDbButton:hover, #fetchSeriesTMDbButton:hover {
            background-color: #27ae60;
        }
        
        .source-input-group {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .source-input-group input {
            flex: 1;
        }
        
        .source-input-group button {
            flex-shrink: 0;
        }
        
        #sourceList, #seriesSourceList {
            margin-top: 10px;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #eee;
            padding: 10px;
            border-radius: 6px;
            background-color: #fafafa;
        }
        
        .source-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background-color: #f1f8ff;
            border-radius: 4px;
            margin-bottom: 6px;
            border-left: 3px solid var(--primary);
        }
        
        .remove-source-btn {
            background: none;
            border: none;
            color: var(--danger);
            font-size: 20px;
            cursor: pointer;
            padding: 0 5px;
            line-height: 1;
        }
        
        /* Seasons & Episodes */
        .season-card {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            border-left: 4px solid var(--primary);
        }
        
        .season-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .episode-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 10px;
        }
        
        .episode-item {
            background-color: white;
            border-radius: 6px;
            padding: 12px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        
        .episode-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        
        .episode-title {
            font-weight: 600;
        }
        
        .episode-meta {
            color: var(--gray);
            font-size: 0.9rem;
        }
        
        .episode-sources {
            margin-top: 8px;
        }
        
        .episode-sources input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .no-results, .no-seasons {
            text-align: center;
            padding: 40px 20px;
            color: var(--gray);
        }
        
        .no-results i {
            font-size: 3rem;
            margin-bottom: 15px;
            opacity: 0.5;
        }
        
        .no-results h3 {
            margin-bottom: 10px;
            color: var(--dark);
        }
        
        .add-episode-btn {
            background-color: var(--primary);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            padding: 5px 10px;
            font-size: 12px;
        }
        
        .add-episode-btn:hover {
            background-color: #2980b9;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .load-section {
                flex-direction: column;
            }
            
            .form-row {
                flex-direction: column;
            }
            
            #entryList {
                grid-template-columns: 1fr;
            }
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <div class="container">
                <header>
            <h1><i class="fas fa-film"></i> CineMax API Manager</h1>
            <p class="subtitle">Complete API management for CineMax with automated TMDB integration</p>
            <div style="margin-top: 15px; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 6px; font-size: 0.9rem;">
                <strong>Quick Start:</strong> 
                1️⃣ Create New CineMax API → 
                2️⃣ Bulk Import from TMDB → 
                3️⃣ Edit Content (optional) → 
                4️⃣ Validate & Export API
            </div>
        </header>

        <div class="card">
            <h2><i class="fas fa-download"></i> 1. Load Data</h2>
            
            <div class="auto-gen-toggle">
                <input type="checkbox" id="autoGenToggle" checked>
                <label for="autoGenToggle">Auto-generate slides, featured, actors, and genres</label>
                <span class="help-text">When enabled, automatically creates related content when you add movies/series</span>
                <button id="manualGenButton" class="btn btn-secondary" style="margin-left: 20px;">
                    <i class="fas fa-magic"></i> Generate Now
                </button>
                <div id="autoGenStatus" style="margin-left: 20px; font-size: 0.9rem; color: var(--success); display: none;">
                    <i class="fas fa-check-circle"></i> Auto-generation active
                </div>
            </div>
            
            <div class="auto-gen-toggle" style="margin-top: 10px;">
                <input type="checkbox" id="autoSaveToggle" checked>
                <label for="autoSaveToggle">Auto-save data locally</label>
                <span class="help-text">Keeps your work safe even after page refresh - data is saved in your browser</span>
                <button id="clearStorageButton" class="btn btn-secondary" style="margin-left: 20px; background-color: var(--danger);">
                    <i class="fas fa-trash"></i> Clear Saved Data
                </button>
                <div id="autoSaveStatus" style="margin-left: 20px; font-size: 0.9rem; color: var(--success); display: none;">
                    <i class="fas fa-save"></i> Auto-save active <span id="lastSaveTime"></span>
                </div>
            </div>
            
            <div class="load-section">
                <div class="load-file">
                    <label for="fileInput">Load JSON file:</label>
                    <input type="file" id="fileInput" accept=".json">
                    <div class="file-info" id="fileInfo" style="margin-top: 10px; font-size: 0.9rem; color: #7f8c8d;"></div>
                    <button id="newCineMaxAPI" style="margin-top: 10px; background-color: var(--success);"><i class="fas fa-plus"></i> New CineMax API</button>
                </div>
                <div class="load-text">
                    <label for="jsonTextInput">Or paste JSON content:</label>
                    <textarea id="jsonTextInput" rows="5" placeholder='{"movies": [], "channels": []}'></textarea>
                    <button id="loadTextButton"><i class="fas fa-file-import"></i> Load from Text</button>
                </div>
            </div>
        </div>

        <div class="card">
            <h2><i class="fas fa-download"></i> 2. Bulk Import from TMDB</h2>
            <div class="bulk-import-section">
                <div class="form-row">
                    <div class="form-group">
                        <label for="tmdbBulkType">Import Type:</label>
                        <select id="tmdbBulkType">
                            <option value="popular-movies">Popular Movies</option>
                            <option value="top-rated-movies">Top Rated Movies</option>
                            <option value="upcoming-movies">Upcoming Movies</option>
                            <option value="now-playing-movies">Now Playing Movies</option>
                            <option value="popular-tv">Popular TV Shows</option>
                            <option value="top-rated-tv">Top Rated TV Shows</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="tmdbBulkPages">Pages to Import (1-10):</label>
                        <input type="number" id="tmdbBulkPages" min="1" max="10" value="2" placeholder="Number of pages">
                    </div>
                </div>
                <button id="bulkImportTMDB" style="background-color: var(--primary);"><i class="fas fa-cloud-download-alt"></i> Bulk Import from TMDB</button>
                <div id="bulkImportProgress" style="margin-top: 10px; display: none;">
                    <div style="background: #f0f0f0; border-radius: 4px; overflow: hidden;">
                        <div id="bulkImportProgressBar" style="background: var(--success); height: 20px; width: 0%; transition: width 0.3s;"></div>
                    </div>
                    <p id="bulkImportStatus" style="margin-top: 5px; font-size: 0.9rem; color: var(--dark);"></p>
                </div>
            </div>
        </div>

        <div class="card">
            <h2><i class="fas fa-edit"></i> 3. Edit Content</h2>
            <div id="editor" style="display: none;">
                <div class="editor-header">
                    <button id="addNewEntry"><i class="fas fa-plus-circle"></i> Add New Content</button>
                    <div class="entry-filters">
                        <button class="filter-btn active" data-filter="all">All</button>
                        <button class="filter-btn" data-filter="movie">Movies</button>
                        <button class="filter-btn" data-filter="series">Series</button>
                        <button class="filter-btn" data-filter="channel">Live TV</button>
                        <button class="filter-btn" data-filter="slides">Slides</button>
                        <button class="filter-btn" data-filter="featured">Featured</button>
                        <button class="filter-btn" data-filter="actors">Actors</button>
                        <button class="filter-btn" data-filter="genres">Genres</button>
                    </div>
                </div>
                <div id="entryList"></div>
            </div>
        </div>

        <div class="card">
            <div id="save-section" style="display: none;">
                <h2><i class="fas fa-save"></i> 4. Export CineMax API</h2>
                <div class="save-section">
                    <button id="saveButton"><i class="fas fa-download"></i> Download CineMax API JSON</button>
                    <button id="validateButton" style="margin-left: 10px; background-color: var(--warning);"><i class="fas fa-check-circle"></i> Validate API</button>
                    <div id="validationResults" style="margin-top: 15px; display: none; padding: 10px; border-radius: 6px; font-size: 0.9rem;"></div>
                </div>
                
                <div class="info-section">
                    <div class="info-toggle" onclick="toggleInfo()">
                        <i class="fas fa-info-circle"></i> About CineMax API Format <i class="fas fa-chevron-down" id="infoChevron"></i>
                    </div>
                    <div class="info-content" id="infoContent">
                        <p><strong>What is CineMax API?</strong></p>
                        <p>CineMax is a movie streaming app that uses a JSON API to manage its content. This tool creates APIs that are fully compatible with the CineMax Android app structure.</p>
                        
                        <p><strong>Key Features:</strong></p>
                        <ul>
                            <li><strong>Movies & TV Shows:</strong> Complete metadata including posters, trailers, cast, and streaming sources</li>
                            <li><strong>Live TV Channels:</strong> Support for live streaming channels with multiple quality options</li>
                            <li><strong>TMDB Integration:</strong> Automatic fetching of movie data, posters, and cast from The Movie Database</li>
                            <li><strong>Auto-generation:</strong> Automatic creation of home slides, featured content, actors, and genres</li>
                            <li><strong>Validation:</strong> Built-in validation to ensure API compatibility</li>
                        </ul>
                        
                        <p><strong>Generated API Structure:</strong></p>
                        <ul>
                            <li><code>api_info</code> - API metadata and statistics</li>
                            <li><code>home</code> - Homepage data with slides, featuredMovies, channels, actors, and genres</li>
                            <li><code>movies</code> - Complete movie/series database</li>
                            <li><code>channels</code> - Live TV channels (also available in home section)</li>
                            <li><code>actors</code> - Cast and crew information (also available in home section)</li>
                            <li><code>genres</code> - Content categories (also available in home section)</li>
                        </ul>
                        
                        <p><strong>Usage in CineMax App:</strong></p>
                        <p>Upload your generated <code>free_movie_api.json</code> to GitHub (or any hosting service), then update the <code>API_URL</code> in <code>Global.java</code> to point to your API file.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal for adding/editing entries -->
    <div id="entryModal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <h2 id="modalTitle"><i class="fas fa-plus-circle"></i> Add New Content</h2>
            
            <div class="category-tabs">
                <button class="tab-btn active" data-type="movie">
                    <i class="fas fa-film"></i> Movie
                </button>
                <button class="tab-btn" data-type="series">
                    <i class="fas fa-tv"></i> Series
                </button>
                <button class="tab-btn" data-type="channel">
                    <i class="fas fa-satellite-dish"></i> Live TV
                </button>
                <button class="tab-btn" data-type="slide">
                    <i class="fas fa-images"></i> Slide
                </button>
                <button class="tab-btn" data-type="actor">
                    <i class="fas fa-user"></i> Actor
                </button>
                <button class="tab-btn" data-type="genre">
                    <i class="fas fa-tags"></i> Genre
                </button>
            </div>
            
            <form id="entryForm">
                <input type="hidden" id="entryId">
                
                <!-- Movie Content -->
                <div class="category-content active" data-type="movie">
                    <div class="form-group">
                        <label for="movieTmdbId">TMDb Movie ID:</label>
                        <div class="tmdb-group">
                            <input type="text" id="movieTmdbId" placeholder="Enter TMDb ID (e.g., 12345)">
                            <button type="button" id="fetchMovieTMDbButton">
                                <i class="fas fa-cloud-download-alt"></i> Fetch Movie
                            </button>
                        </div>
                    </div>
                    
                    <div class="form-row">
                        <div class="form-group">
                            <label for="movieTitle">Title:</label>
                            <input type="text" id="movieTitle" required>
                        </div>
                        <div class="form-group">
                            <label for="movieYear">Year:</label>
                            <input type="text" id="movieYear">
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label for="movieDescription">Description:</label>
                        <textarea id="movieDescription" rows="3"></textarea>
                    </div>
                    
                    <div class="form-row">
                        <div class="form-group">
                            <label for="movieImage">Poster URL:</label>
                            <input type="text" id="movieImage">
                        </div>
                        <div class="form-group">
                            <label for="movieCover">Cover URL:</label>
                            <input type="text" id="movieCover">
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label for="movieTrailer">Trailer URL:</label>
                        <input type="text" id="movieTrailer" placeholder="YouTube URL">
                    </div>
                    
                    <div class="form-group">
                        <label>Video Sources</label>
                        <div id="movieSourceList"></div>
                        <div class="source-input-group">
                            <input type="text" id="movieSourceNameInput" placeholder="Source Name (e.g., 1080p)">
                            <input type="text" id="movieSourceUrlInput" placeholder="Source URL">
                            <button type="button" id="addMovieSourceButton">
                                <i class="fas fa-plus"></i> Add
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Series Content -->
                <div class="category-content" data-type="series">
                    <div class="form-group">
                        <label for="seriesTmdbId">TMDb Series ID:</label>
                        <div class="tmdb-group">
                            <input type="text" id="seriesTmdbId" placeholder="Enter TMDb ID (e.g., 12345)">
                            <button type="button" id="fetchSeriesTMDbButton">
                                <i class="fas fa-cloud-download-alt"></i> Fetch Series
                            </button>
                        </div>
                    </div>
                    
                    <div class="form-row">
                        <div class="form-group">
                            <label for="seriesTitle">Title:</label>
                            <input type="text" id="seriesTitle" required>
                        </div>
                        <div class="form-group">
                            <label for="seriesYear">Year:</label>
                            <input type="text" id="seriesYear">
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label for="seriesDescription">Description:</label>
                        <textarea id="seriesDescription" rows="3"></textarea>
                    </div>
                    
                    <div class="form-row">
                        <div class="form-group">
                            <label for="seriesImage">Poster URL:</label>
                            <input type="text" id="seriesImage">
                        </div>
                        <div class="form-group">
                            <label for="seriesCover">Cover URL:</label>
                            <input type="text" id="seriesCover">
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label for="seriesTrailer">Trailer URL:</label>
                        <input type="text" id="seriesTrailer" placeholder="YouTube URL">
                    </div>
                    
                    <div class="form-group">
                        <label>Seasons & Episodes</label>
                        <div id="seasonContainer"></div>
                    </div>
                </div>
                
                <!-- Live TV Content -->
                <div class="category-content" data-type="channel">
                    <div class="form-group">
                        <label for="channelTitle">Channel Name:</label>
                        <input type="text" id="channelTitle" required>
                    </div>
                    
                    <div class="form-group">
                        <label for="channelImage">Logo URL:</label>
                        <input type="text" id="channelImage">
                    </div>
                    
                    <div class="form-row">
                        <div class="form-group">
                            <label for="channelRating">Rating (1-10):</label>
                            <input type="number" id="channelRating" min="1" max="10" step="0.1">
                        </div>
                        <div class="form-group">
                            <label for="channelCategory">Category:</label>
                            <input type="text" id="channelCategory" placeholder="e.g., News, Sports">
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label for="channelDescription">Description:</label>
                        <textarea id="channelDescription" rows="3"></textarea>
                    </div>
                    
                    <div class="form-group">
                        <label for="channelStreamUrl">Stream URL:</label>
                        <input type="text" id="channelStreamUrl" required placeholder="Main stream URL">
                    </div>
                    
                    <div class="form-group">
                        <label for="channelBackupUrl">Backup URL (optional):</label>
                        <input type="text" id="channelBackupUrl" placeholder="Backup stream URL">
                    </div>
                </div>
                
                <!-- Slide Content -->
                <div class="category-content" data-type="slide">
                    <div class="form-row">
                        <div class="form-group">
                            <label for="slideTitle">Slide Title:</label>
                            <input type="text" id="slideTitle" required>
                        </div>
                        <div class="form-group">
                            <label for="slideType">Type:</label>
                            <select id="slideType">
                                <option value="movie">Movie</option>
                                <option value="series">Series</option>
                                <option value="channel">Channel</option>
                            </select>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label for="slideImage">Image URL:</label>
                        <input type="text" id="slideImage">
                    </div>
                    
                    <div class="form-group">
                        <label for="slideUrl">URL:</label>
                        <input type="text" id="slideUrl" placeholder="e.g., movies/1">
                    </div>
                </div>
                
                <!-- Actor Content -->
                <div class="category-content" data-type="actor">
                    <div class="form-row">
                        <div class="form-group">
                            <label for="actorName">Name:</label>
                            <input type="text" id="actorName" required>
                        </div>
                        <div class="form-group">
                            <label for="actorType">Type:</label>
                            <select id="actorType">
                                <option value="actor">Actor</option>
                                <option value="actress">Actress</option>
                                <option value="director">Director</option>
                            </select>
                        </div>
                    </div>
                    
                    <div class="form-row">
                        <div class="form-group">
                            <label for="actorRole">Role:</label>
                            <input type="text" id="actorRole" placeholder="e.g., Lead Actor">
                        </div>
                        <div class="form-group">
                            <label for="actorBorn">Born:</label>
                            <input type="date" id="actorBorn">
                        </div>
                    </div>
                    
                    <div class="form-row">
                        <div class="form-group">
                            <label for="actorHeight">Height:</label>
                            <input type="text" id="actorHeight" placeholder="e.g., 5'10\"">
                        </div>
                        <div class="form-group">
                            <label for="actorImage">Image URL:</label>
                            <input type="text" id="actorImage">
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label for="actorBio">Biography:</label>
                        <textarea id="actorBio" rows="3"></textarea>
                    </div>
                </div>
                
                <!-- Genre Content -->
                <div class="category-content" data-type="genre">
                    <div class="form-group">
                        <label for="genreTitle">Genre Name:</label>
                        <input type="text" id="genreTitle" required placeholder="e.g., Action, Comedy, Drama">
                    </div>
                    
                    <div class="form-group">
                        <label for="genreDescription">Description (Optional):</label>
                        <textarea id="genreDescription" rows="2" placeholder="Brief description of the genre"></textarea>
                    </div>
                </div>
                
                <div class="form-group" style="margin-top: 20px; text-align: center;">
                    <button type="submit" id="modalSaveButton" style="padding: 12px 30px; font-size: 1.1rem;">
                        <i class="fas fa-save"></i> Save Content
                    </button>
                </div>
            </form>
        </div>
    </div>

    <script>
        // Global error handler to prevent white screen
        window.addEventListener('error', (event) => {
            console.error('Global error caught:', event.error);
            showNotification(`Unexpected error: ${event.error.message}`, false);
            return true; // Prevent default browser error handling
        });

        window.addEventListener('unhandledrejection', (event) => {
            console.error('Unhandled promise rejection:', event.reason);
            showNotification(`Promise error: ${event.reason}`, false);
            event.preventDefault();
        });

        // IMMEDIATE TEST - This should show up first
        console.log('🔥 JAVASCRIPT IS LOADING! 🔥');
        alert('JavaScript is working! Check console for details.');

        document.addEventListener('DOMContentLoaded', () => {
            console.log('🚀 DOM Content Loaded - Initializing app...');
            alert('DOM loaded! App is starting...');
            
            // --- Constants and Config ---
            const tmdbApiKey = 'ec926176bf467b3f7735e3154238c161';
            
            // --- Element References ---
            const fileInput = document.getElementById('fileInput');
            const fileInfo = document.getElementById('fileInfo');
            const jsonTextInput = document.getElementById('jsonTextInput');
            const loadTextButton = document.getElementById('loadTextButton');
            const editorDiv = document.getElementById('editor');
            const saveSectionDiv = document.getElementById('save-section');
            const entryListDiv = document.getElementById('entryList');
            const addNewEntryButton = document.getElementById('addNewEntry');
            const saveButton = document.getElementById('saveButton');
            const filterButtons = document.querySelectorAll('.filter-btn');
            
            // Modal elements
            const modal = document.getElementById('entryModal');
            const modalTitle = document.getElementById('modalTitle');
            const closeModalButton = document.querySelector('.close-button');
            const entryForm = document.getElementById('entryForm');
            const entryIdInput = document.getElementById('entryId');
            const tabButtons = document.querySelectorAll('.tab-btn');
            
            // Movie elements
            const movieTmdbIdInput = document.getElementById('movieTmdbId');
            const fetchMovieTMDbButton = document.getElementById('fetchMovieTMDbButton');
            const movieTitleInput = document.getElementById('movieTitle');
            const movieYearInput = document.getElementById('movieYear');
            const movieDescriptionInput = document.getElementById('movieDescription');
            const movieImageInput = document.getElementById('movieImage');
            const movieCoverInput = document.getElementById('movieCover');
            const movieTrailerInput = document.getElementById('movieTrailer');
            const movieSourceListDiv = document.getElementById('movieSourceList');
            const movieSourceNameInput = document.getElementById('movieSourceNameInput');
            const movieSourceUrlInput = document.getElementById('movieSourceUrlInput');
            const addMovieSourceButton = document.getElementById('addMovieSourceButton');
            
            // Series elements
            const seriesTmdbIdInput = document.getElementById('seriesTmdbId');
            const fetchSeriesTMDbButton = document.getElementById('fetchSeriesTMDbButton');
            const seriesTitleInput = document.getElementById('seriesTitle');
            const seriesYearInput = document.getElementById('seriesYear');
            const seriesDescriptionInput = document.getElementById('seriesDescription');
            const seriesImageInput = document.getElementById('seriesImage');
            const seriesCoverInput = document.getElementById('seriesCover');
            const seriesTrailerInput = document.getElementById('seriesTrailer');
            const seasonContainerDiv = document.getElementById('seasonContainer');
            
            // Channel elements
            const channelTitleInput = document.getElementById('channelTitle');
            const channelImageInput = document.getElementById('channelImage');
            const channelRatingInput = document.getElementById('channelRating');
            const channelCategoryInput = document.getElementById('channelCategory');
            const channelDescriptionInput = document.getElementById('channelDescription');
            const channelStreamUrlInput = document.getElementById('channelStreamUrl');
            const channelBackupUrlInput = document.getElementById('channelBackupUrl');
            
            // --- State Management ---
            let jsonData = null;
            let currentMovieSources = [];
            let currentMovieGenres = [];
            let currentFilter = 'all';
            let currentSeriesData = { seasons: [] };
            let currentSeriesGenres = [];
            let currentSeriesActors = [];
            let autoGenerationEnabled = true; // Global control for auto-generation
            
            const STORAGE_KEY = 'cinemax_api_data';
            const AUTO_SAVE_ENABLED_KEY = 'cinemax_auto_save_enabled';

            // SIMPLE CLICK TEST
            console.log('🧪 Setting up simple click tests...');
            
            // Test 1: Save button
            const testButton = document.querySelector('#saveButton');
            if (testButton) {
                console.log('✅ Save button found!');
                testButton.addEventListener('click', () => {
                    console.log('🎯 SAVE BUTTON WAS CLICKED!');
                    alert('Save button clicked! This means event listeners work.');
                });
            } else {
                console.log('❌ Save button NOT found!');
            }

            // Test 2: Form
            const testForm = document.querySelector('#entryForm');
            if (testForm) {
                console.log('✅ Entry form found!');
                // We'll add the real form handler later - this is just for testing if the form exists
            } else {
                console.log('❌ Entry form NOT found!');
                alert('CRITICAL ERROR: Entry form not found! Modal form is missing.');
            }

            // Test 3: Add new entry button
            const addButton = document.querySelector('#addNewEntry');
            if (addButton) {
                console.log('✅ Add new entry button found!');
                addButton.addEventListener('click', () => {
                    console.log('🎯 ADD NEW ENTRY BUTTON CLICKED!');
                    alert('Add new entry clicked! Modal should open.');
                });
            } else {
                console.log('❌ Add new entry button NOT found!');
            }

            // Test 4: Modal Save Button (the one that's not working)
            const modalSaveButton = document.querySelector('#modalSaveButton');
            if (modalSaveButton) {
                console.log('✅ Modal Save button found!');
                modalSaveButton.addEventListener('click', (e) => {
                    console.log('🎯 MODAL SAVE BUTTON WAS CLICKED DIRECTLY!');
                    console.log('Button type:', modalSaveButton.type);
                    console.log('Form element:', modalSaveButton.form);
                    
                    // The issue is likely that the form isn't submitting
                    // Let's manually trigger the form submit
                    e.preventDefault(); // Prevent default button behavior
                    
                    if (modalSaveButton.form) {
                        console.log('🚀 Manually triggering form submit...');
                        const submitEvent = new Event('submit', { bubbles: true, cancelable: true });
                        modalSaveButton.form.dispatchEvent(submitEvent);
                    } else {
                        console.log('❌ Button is not associated with a form! Calling save directly...');
                        
                        // Direct save as fallback
                        try {
                            console.log('🔧 DIRECT SAVE FALLBACK TRIGGERED!');
                            
                            if (!jsonData) {
                                alert('ERROR: No JSON data loaded. Please load a JSON file first.');
                                return;
                            }
                            
                            const activeTabElement = document.querySelector('.tab-btn.active');
                            if (!activeTabElement) {
                                alert('ERROR: No active tab found. Please select Movie, Series, or Channel.');
                                return;
                            }
                            
                            const activeTab = activeTabElement.dataset.type;
                            console.log('Active tab for direct save:', activeTab);
                            
                            // Get form data and save
                            const id = entryIdInput.value;
                            
                            if (activeTab === 'movie') {
                                if (!movieTitleInput.value.trim()) {
                                    alert('ERROR: Movie title is required');
                                    return;
                                }
                                saveMovie(id);
                                alert('Movie saved successfully!');
                            } else if (activeTab === 'series') {
                                if (!seriesTitleInput.value.trim()) {
                                    alert('ERROR: Series title is required');
                                    return;
                                }
                                saveSeries(id);
                                alert('Series saved successfully!');
                            } else if (activeTab === 'channel') {
                                if (!channelTitleInput.value.trim()) {
                                    alert('ERROR: Channel name is required');
                                    return;
                                }
                                if (!channelStreamUrlInput.value.trim()) {
                                    alert('ERROR: Stream URL is required');
                                    return;
                                }
                                saveChannel(id);
                                alert('Channel saved successfully!');
                            }
                            
                            // Update UI and auto-generate related content
                            autoGenerateRelatedContent();
                            renderEntries();
                            // Auto-save after adding/editing entry
                            saveToLocalStorage();
                            closeModal();
                            
                        } catch (error) {
                            console.error('Direct save error:', error);
                            alert('Save error: ' + error.message);
                        }
                    }
                });
            } else {
                console.log('❌ Modal Save button NOT found!');
                alert('CRITICAL: Modal Save button not found!');
            }

            // REAL FORM SUBMIT HANDLER - This is the important one!
            console.log('🔧 Setting up REAL form submit handler...');
            if (testForm) {
                testForm.addEventListener('submit', (event) => {
                    event.preventDefault();
                    
                    console.log('🔥 REAL FORM SUBMIT TRIGGERED! 🔥');
                    alert('REAL form submit working! Now processing...');
                    
                    try {
                        console.log('=== FORM SUBMIT STARTED ===');
                        console.log('Event:', event);
                        
                        // Prevent double submission
                        const submitButton = event.target.querySelector('button[type="submit"]');
                        if (submitButton.disabled) {
                            console.log('Button already disabled - preventing double submit');
                            alert('Please wait, saving in progress...');
                            return;
                        }
                        
                        // Disable submit button temporarily
                        submitButton.disabled = true;
                        submitButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Saving...';
                        
                        console.log('=== CHECKING BASIC ELEMENTS ===');
                        
                        if (!jsonData) {
                            throw new Error('No JSON data loaded. Please load a JSON file first.');
                        }
                        
                        const id = entryIdInput.value;
                        console.log('Entry ID:', id);
                        
                        const activeTabElement = document.querySelector('.tab-btn.active');
                        if (!activeTabElement) {
                            throw new Error('No active tab found');
                        }
                        
                        const activeTab = activeTabElement.dataset.type;
                        console.log('Active tab:', activeTab);
                        
                        // Validate required fields
                        console.log('=== VALIDATING FIELDS ===');
                        let isValid = true;
                        let errorMessage = '';
                        
                        if (activeTab === 'movie') {
                            console.log('Movie title value:', movieTitleInput.value);
                            if (!movieTitleInput.value.trim()) {
                                isValid = false;
                                errorMessage = 'Movie title is required';
                            }
                        } else if (activeTab === 'series') {
                            console.log('Series title value:', seriesTitleInput.value);
                            if (!seriesTitleInput.value.trim()) {
                                isValid = false;
                                errorMessage = 'Series title is required';
                            }
                        } else if (activeTab === 'channel') {
                            console.log('Channel title value:', channelTitleInput.value);
                            console.log('Channel stream URL value:', channelStreamUrlInput.value);
                            if (!channelTitleInput.value.trim()) {
                                isValid = false;
                                errorMessage = 'Channel name is required';
                            }
                            if (!channelStreamUrlInput.value.trim()) {
                                isValid = false;
                                errorMessage = 'Stream URL is required';
                            }
                        }
                        
                        if (!isValid) {
                            console.log('Validation failed:', errorMessage);
                            alert('Validation failed: ' + errorMessage);
                            return;
                        }
                        
                        console.log('=== SAVING DATA ===');
                        // Save the data
                        if (activeTab === 'channel') {
                            console.log('Calling saveChannel...');
                            saveChannel(id);
                        } else if (activeTab === 'series') {
                            console.log('Calling saveSeries...');
                            saveSeries(id);
                        } else {
                            console.log('Calling saveMovie...');
                            saveMovie(id);
                        }
                        
                        console.log('=== UPDATING UI ===');
                        renderEntries();
                        closeModal();
                        alert(`${activeTab.charAt(0).toUpperCase() + activeTab.slice(1)} saved successfully!`);
                        console.log('=== SAVE COMPLETED SUCCESSFULLY ===');
                        
                    } catch (error) {
                        console.error('=== SAVE ERROR ===', error);
                        console.error('Error stack:', error.stack);
                        alert(`Error saving content: ${error.message}`);
                    } finally {
                        // Re-enable submit button
                        const submitButton = event.target.querySelector('button[type="submit"]');
                        if (submitButton) {
                            submitButton.disabled = false;
                            submitButton.innerHTML = '<i class="fas fa-save"></i> Save Content';
                        }
                    }
                });
                console.log('✅ Real form submit handler attached successfully!');
            } else {
                console.log('❌ Cannot attach form handler - form not found!');
                alert('CRITICAL: Cannot attach form submit handler!');
            }

            // Test 5: Manual Form Submit Test
            console.log('🧪 Adding manual form submit test...');
            window.testFormSubmit = function() {
                console.log('🔥 MANUAL TEST: Triggering form submit...');
                if (testForm) {
                    const event = new Event('submit', { bubbles: true, cancelable: true });
                    testForm.dispatchEvent(event);
                    console.log('✅ Manual form submit triggered');
                } else {
                    console.log('❌ Cannot test - form not found');
                }
            };
            console.log('✅ You can now test with: testFormSubmit() in console');
            
            // Add manual test for auto-generation
            window.testAutoGeneration = function() {
                console.log('🧪 MANUAL TEST: Running auto-generation...');
                if (jsonData) {
                    autoGenerateRelatedContent();
                    renderEntries();
                    alert('Auto-generation test completed! Check console and filters.');
                } else {
                    alert('ERROR: No JSON data loaded. Load data first.');
                }
            };
            console.log('✅ You can test auto-generation with: testAutoGeneration() in console');
            
            // --- Auto-Generation Control ---
            const autoGenToggle = document.getElementById('autoGenToggle');
            const manualGenButton = document.getElementById('manualGenButton');
            
            if (autoGenToggle) {
                autoGenToggle.addEventListener('change', (e) => {
                    autoGenerationEnabled = e.target.checked;
                    console.log(`Auto-generation ${autoGenerationEnabled ? 'enabled' : 'disabled'}`);
                    showNotification(`Auto-generation ${autoGenerationEnabled ? 'enabled' : 'disabled'}`, true);
                    
                    // Update status indicator
                    const statusElement = document.getElementById('autoGenStatus');
                    if (statusElement) {
                        statusElement.style.display = autoGenerationEnabled ? 'inline-block' : 'none';
                    }
                });
                
                // Initialize status indicator
                const statusElement = document.getElementById('autoGenStatus');
                if (statusElement && autoGenerationEnabled) {
                    statusElement.style.display = 'inline-block';
                }
            }
            
            if (manualGenButton) {
                manualGenButton.addEventListener('click', () => {
                    if (!jsonData) {
                        showNotification('Please load data first before generating content', false);
                        return;
                    }
                    
                    console.log('🔧 Manual generation triggered...');
                    showNotification('Generating related content...', true);
                    
                    // Temporarily enable auto-generation for manual trigger
                    const wasEnabled = autoGenerationEnabled;
                    autoGenerationEnabled = true;
                    
                    autoGenerateRelatedContent();
                    renderEntries();
                    
                    // Restore previous state
                    autoGenerationEnabled = wasEnabled;
                    
                    showNotification('Content generation completed!', true);
                });
            }
            
            // --- Auto-Save Control ---
            const autoSaveToggle = document.getElementById('autoSaveToggle');
            const clearStorageButton = document.getElementById('clearStorageButton');
            let autoSaveEnabled = true;
            
            // Load auto-save preference
            const savedAutoSavePreference = localStorage.getItem(AUTO_SAVE_ENABLED_KEY);
            if (savedAutoSavePreference !== null) {
                autoSaveEnabled = JSON.parse(savedAutoSavePreference);
                if (autoSaveToggle) {
                    autoSaveToggle.checked = autoSaveEnabled;
                }
            }
            
            if (autoSaveToggle) {
                autoSaveToggle.addEventListener('change', (e) => {
                    autoSaveEnabled = e.target.checked;
                    localStorage.setItem(AUTO_SAVE_ENABLED_KEY, JSON.stringify(autoSaveEnabled));
                    console.log(`Auto-save ${autoSaveEnabled ? 'enabled' : 'disabled'}`);
                    showNotification(`Auto-save ${autoSaveEnabled ? 'enabled' : 'disabled'}`, true);
                    
                    // Update status indicator
                    const statusElement = document.getElementById('autoSaveStatus');
                    if (statusElement) {
                        statusElement.style.display = autoSaveEnabled ? 'inline-block' : 'none';
                    }
                    
                    // If enabled, save current data immediately
                    if (autoSaveEnabled && jsonData) {
                        saveToLocalStorage();
                    }
                });
                
                // Initialize status indicator
                const statusElement = document.getElementById('autoSaveStatus');
                if (statusElement && autoSaveEnabled) {
                    statusElement.style.display = 'inline-block';
                }
            }
            
            if (clearStorageButton) {
                clearStorageButton.addEventListener('click', () => {
                    if (confirm('Are you sure you want to clear all saved data? This action cannot be undone.')) {
                        localStorage.removeItem(STORAGE_KEY);
                        showNotification('Saved data cleared successfully!', true);
                        console.log('🗑️ Local storage cleared');
                    }
                });
            }
            
            // --- Auto-Save Functions ---
            function saveToLocalStorage() {
                if (!autoSaveEnabled || !jsonData) return;
                
                try {
                    const now = new Date();
                    const dataToSave = {
                        timestamp: now.toISOString(),
                        data: jsonData
                    };
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(dataToSave));
                    console.log('💾 Data auto-saved to localStorage');
                    
                    // Update the last save time display
                    const lastSaveElement = document.getElementById('lastSaveTime');
                    if (lastSaveElement) {
                        lastSaveElement.textContent = `(Last saved: ${now.toLocaleTimeString()})`;
                    }
                } catch (error) {
                    console.warn('Failed to save to localStorage:', error);
                    if (error.name === 'QuotaExceededError') {
                        showNotification('Auto-save failed: Storage quota exceeded. Consider clearing old data.', false);
                    }
                }
            }
            
            function loadFromLocalStorage() {
                try {
                    const savedData = localStorage.getItem(STORAGE_KEY);
                    if (savedData) {
                        const parsed = JSON.parse(savedData);
                        if (parsed.data) {
                            jsonData = parsed.data;
                            
                            // Initialize the UI
                            editorDiv.style.display = 'block';
                            saveSectionDiv.style.display = 'block';
                            renderEntries();
                            
                            const saveTime = new Date(parsed.timestamp).toLocaleString();
                            showNotification(`Data restored from auto-save (${saveTime})`, true);
                            console.log('✅ Data loaded from localStorage');
                            return true;
                        }
                    }
                } catch (error) {
                    console.warn('Failed to load from localStorage:', error);
                    localStorage.removeItem(STORAGE_KEY); // Clean up corrupted data
                }
                return false;
            }

            // --- CineMax API Structure Functions ---
            function createNewCineMaxAPI() {
                console.log('🚀 Creating new CineMax API structure...');
                
                jsonData = {
                    api_info: {
                        version: "2.0",
                        description: "Enhanced Free Movie & TV Streaming JSON API with Full Actor Support",
                        last_updated: new Date().toISOString().split('T')[0],
                        total_movies: 0,
                        total_channels: 0,
                        total_actors: 0
                    },
                    home: {
                        slides: [],
                        featured_movies: []
                    },
                    movies: [],
                    channels: [],
                    actors: [],
                    genres: []
                };
                
                // Auto-save the new structure
                saveToLocalStorage();
                
                // Initialize the UI
                editorDiv.style.display = 'block';
                saveSectionDiv.style.display = 'block';
                renderEntries();
                
                showNotification('New CineMax API structure created successfully!', true);
                console.log('✅ CineMax API structure ready');
            }

            // --- Auto-Generation Functions ---
            function autoGenerateRelatedContent() {
                if (!autoGenerationEnabled) {
                    console.log('⏸️ Auto-generation disabled, skipping...');
                    return;
                }
                
                console.log('🔄 Auto-generating slides, featured content, actors, and genres...');
                
                try {
                    // Initialize structures
                    if (!jsonData.home) jsonData.home = {};
                    if (!jsonData.home.slides) jsonData.home.slides = [];
                    if (!jsonData.home.featured_movies) jsonData.home.featured_movies = [];
                    if (!jsonData.actors) jsonData.actors = [];
                    if (!jsonData.genres) jsonData.genres = [];
                    if (!jsonData.api_info) jsonData.api_info = {
                        version: "2.0",
                        description: "Enhanced Free Movie & TV Streaming JSON API with Full Actor Support",
                        last_updated: new Date().toISOString().split('T')[0],
                        total_movies: 0,
                        total_channels: 0,
                        total_actors: 0
                    };
                    
                    // Auto-generate slides from top-rated content
                    autoGenerateSlides();
                    
                    // Auto-generate featured movies (high-rated movies)
                    autoGenerateFeaturedMovies();
                    
                    // Auto-generate actors from movie/series data
                    autoGenerateActors();
                    
                    // Auto-generate genres from movie/series data
                    autoGenerateGenres();
                    
                    // Update API info
                    updateApiInfo();
                    
                    console.log('✅ Auto-generation completed successfully');
                } catch (error) {
                    console.error('❌ Error in auto-generation:', error);
                }
            }
            
            function autoGenerateSlides() {
                console.log('📸 Generating slides...');
                
                // Get top content for slides (movies, series, channels with images)
                const allContent = [
                    ...(jsonData.movies || []).map(m => ({...m, contentType: 'movie', url: `movies/${m.id}`})),
                    ...(jsonData.channels || []).map(c => ({...c, contentType: 'channel', url: `channels/${c.id}`}))
                ];
                
                // Filter content with images and sort by rating, then by year (newer first)
                const slideContent = allContent
                    .filter(item => item.image && item.title)
                    .sort((a, b) => {
                        // First sort by rating (high to low)
                        const ratingDiff = (b.rating || 0) - (a.rating || 0);
                        if (ratingDiff !== 0) return ratingDiff;
                        // Then by year (newer first)
                        return (b.year || 0) - (a.year || 0);
                    })
                    .slice(0, 5); // Top 5 for slides
                
                // Generate slides - create at least one default slide if no content
                if (slideContent.length === 0) {
                    jsonData.home.slides = [{
                        id: 1,
                        title: "Welcome to Movie API",
                        type: "movie",
                        image: "https://via.placeholder.com/800x400/2c3e50/ffffff?text=Add+Your+First+Movie",
                        url: "movies/1",
                        poster: {
                            id: 1,
                            title: "Welcome to Movie API",
                            type: "movie",
                            label: "Getting Started",
                            sublabel: "Add Content",
                            description: "Start by adding your first movie or TV show!",
                            image: "https://via.placeholder.com/800x400/2c3e50/ffffff?text=Add+Your+First+Movie"
                        }
                    }];
                } else {
                    jsonData.home.slides = slideContent.map((item, index) => ({
                        id: index + 1,
                        title: item.title,
                        type: item.contentType,
                        image: item.image,
                        url: item.url,
                        poster: item.contentType === 'movie' ? { 
                            ...item,
                            label: item.contentType === 'movie' ? 'Latest Movie' : 'Featured Content',
                            sublabel: item.year ? `Released ${item.year}` : 'New Release',
                            description: item.description || item.overview || 'Check out this amazing content!'
                        } : null,
                        channel: item.contentType === 'channel' ? { ...item } : null
                    }));
                }
                
                console.log(`✅ Generated ${jsonData.home.slides.length} slides`);
            }
            
            function autoGenerateFeaturedMovies() {
                console.log('⭐ Generating featured movies...');
                
                // Get movies with rating >= 7 or recent movies (last 3 years)
                const currentYear = new Date().getFullYear();
                const featuredMovies = (jsonData.movies || [])
                    .filter(movie => {
                        const hasGoodRating = movie.rating >= 7;
                        const isRecent = movie.year >= (currentYear - 3);
                        const hasImage = movie.image;
                        return (hasGoodRating || isRecent) && hasImage;
                    })
                    .sort((a, b) => {
                        // First sort by rating (high to low)
                        const ratingDiff = (b.rating || 0) - (a.rating || 0);
                        if (ratingDiff !== 0) return ratingDiff;
                        // Then by year (newer first)
                        return (b.year || 0) - (a.year || 0);
                    })
                    .slice(0, 12); // Top 12 featured
                
                // If no featured movies, use all available movies
                if (featuredMovies.length === 0 && jsonData.movies.length > 0) {
                    const fallbackMovies = jsonData.movies
                        .filter(movie => movie.image) // Only movies with images
                        .sort((a, b) => (b.rating || 0) - (a.rating || 0))
                        .slice(0, 8); // Top 8 as fallback
                    
                    jsonData.home.featured_movies = fallbackMovies.map(movie => ({
                        ...movie,
                        views: movie.views || Math.floor(Math.random() * 10000) + 1000, // Random views
                        created_at: movie.created_at || new Date().toISOString().split('T')[0]
                    }));
                } else {
                    jsonData.home.featured_movies = featuredMovies.map(movie => ({
                        ...movie,
                        views: movie.views || Math.floor(Math.random() * 10000) + 1000, // Random views
                        created_at: movie.created_at || new Date().toISOString().split('T')[0]
                    }));
                }
                
                console.log(`✅ Generated ${jsonData.home.featured_movies.length} featured movies`);
            }
            
            function autoGenerateActors() {
                console.log('👥 Generating actors...');
                
                const actorMap = new Map();
                
                // Collect actors from movies and series
                (jsonData.movies || []).forEach(movie => {
                    if (movie.actors && movie.actors.length > 0) {
                        movie.actors.forEach(actor => {
                            if (actor.name && actor.name.trim() !== '') {
                                const key = actor.name.toLowerCase();
                                if (!actorMap.has(key)) {
                                    actorMap.set(key, {
                                        id: actorMap.size + 1,
                                        name: actor.name,
                                        type: actor.type || 'actor',
                                        role: actor.role || 'Actor',
                                        image: actor.image || '',
                                        born: actor.born || '',
                                        height: actor.height || '',
                                        bio: actor.bio || '',
                                        movies: []
                                    });
                                }
                                
                                // Add movie to actor's filmography
                                const actorData = actorMap.get(key);
                                actorData.movies.push({
                                    id: movie.id,
                                    title: movie.title,
                                    image: movie.image,
                                    year: movie.year
                                });
                            }
                        });
                    }
                });
                
                // Add default actors if none exist
                if (actorMap.size === 0) {
                    const defaultActors = [
                        { name: 'Unknown Actor', type: 'actor', role: 'Lead Actor' },
                        { name: 'Unknown Actress', type: 'actress', role: 'Lead Actress' }
                    ];
                    defaultActors.forEach((actor, index) => {
                        actorMap.set(actor.name.toLowerCase(), {
                            id: index + 1,
                            name: actor.name,
                            type: actor.type,
                            role: actor.role,
                            image: '',
                            born: '',
                            height: '',
                            bio: 'Add actor details when creating movies',
                            movies: []
                        });
                    });
                }
                
                jsonData.actors = Array.from(actorMap.values());
                console.log(`✅ Generated ${jsonData.actors.length} actors`);
            }
            
            function autoGenerateGenres() {
                console.log('🏷️ Generating genres...');
                
                const genreMap = new Map();
                
                // Collect genres from movies and series
                (jsonData.movies || []).forEach(movie => {
                    if (movie.genres && movie.genres.length > 0) {
                        movie.genres.forEach(genre => {
                            const genreName = genre.name || genre.title; // Support both name and title
                            if (genreName && genreName.trim() !== '') {
                                const key = genreName.toLowerCase();
                                if (!genreMap.has(key)) {
                                    genreMap.set(key, {
                                        id: genreMap.size + 1,
                                        title: genreName,  // Root-level genres use "title"
                                        posters: []
                                    });
                                }
                                
                                // Add complete movie data to genre
                                const genreData = genreMap.get(key);
                                if (movie.image && !genreData.posters.find(p => p.id === movie.id)) {
                                    genreData.posters.push({
                                        id: movie.id,
                                        title: movie.title,
                                        type: movie.type || 'movie',
                                        label: movie.label || 'Movie',
                                        sublabel: movie.sublabel || movie.year || 'N/A',
                                        imdb: movie.imdb || '0.0',
                                        downloadas: movie.downloadas || movie.title?.toLowerCase().replace(/[^a-z0-9]/g, '-') || '',
                                        comment: movie.comment !== undefined ? movie.comment : true,
                                        playas: movie.playas || 'video',
                                        description: movie.description || '',
                                        classification: movie.classification || 'PG-13',
                                        year: movie.year || 'N/A',
                                        duration: movie.duration || '00:00',
                                        rating: movie.rating || 0,
                                        image: movie.image,
                                        cover: movie.cover || movie.image || '',
                                        genres: movie.genres || [],
                                        actors: movie.actors || [],
                                        views: movie.views || 0,
                                        created_at: movie.created_at || new Date().toISOString().split('T')[0],
                                        sources: movie.sources || [],
                                        trailer: movie.trailer || null,
                                        subtitles: movie.subtitles || [],
                                        comments: movie.comments || [],
                                        downloads: movie.downloads || 0,
                                        shares: movie.shares || 0,
                                        ...(movie.type === 'series' && { seasons: movie.seasons || [] })
                                    });
                                }
                            }
                        });
                    }
                });
                
                // Add default genres if none exist
                if (genreMap.size === 0) {
                    const defaultGenres = ['Action', 'Comedy', 'Drama', 'Horror', 'Sci-Fi', 'Animation'];
                    defaultGenres.forEach((genreName, index) => {
                        genreMap.set(genreName.toLowerCase(), {
                            id: index + 1,
                            title: genreName,
                            posters: []
                        });
                    });
                }
                
                jsonData.genres = Array.from(genreMap.values());
                console.log(`✅ Generated ${jsonData.genres.length} genres`);
            }
            
            function updateApiInfo() {
                console.log('📊 Updating API info...');
                
                jsonData.api_info.total_movies = (jsonData.movies || []).length;
                jsonData.api_info.total_channels = (jsonData.channels || []).length;
                jsonData.api_info.total_actors = (jsonData.actors || []).length;
                jsonData.api_info.last_updated = new Date().toISOString().split('T')[0];
                
                console.log(`✅ Updated API info: ${jsonData.api_info.total_movies} movies, ${jsonData.api_info.total_channels} channels, ${jsonData.api_info.total_actors} actors`);
            }
            
            // --- Utility Functions ---
            function showNotification(message, isSuccess = true) {
                try {
                    console.log('Showing notification:', message, 'Success:', isSuccess);
                    
                    const notification = document.createElement('div');
                    notification.textContent = message;
                    notification.style.position = 'fixed';
                    notification.style.top = '20px';
                    notification.style.right = '20px';
                    notification.style.padding = '15px 25px';
                    notification.style.background = isSuccess ? '#2ecc71' : '#e74c3c';
                    notification.style.color = 'white';
                    notification.style.borderRadius = '6px';
                    notification.style.boxShadow = '0 4px 12px rgba(0,0,0,0.15)';
                    notification.style.zIndex = '10000';
                    notification.style.opacity = '0';
                    notification.style.transform = 'translateX(100px)';
                    notification.style.transition = 'all 0.3s ease';
                    notification.style.maxWidth = '400px';
                    notification.style.wordWrap = 'break-word';
                    
                    document.body.appendChild(notification);
                    
                    // Animate in
                    setTimeout(() => {
                        notification.style.opacity = '1';
                        notification.style.transform = 'translateX(0)';
                    }, 10);
                    
                    // Remove after delay
                    setTimeout(() => {
                        notification.style.opacity = '0';
                        notification.style.transform = 'translateX(100px)';
                        setTimeout(() => {
                            try {
                                if (notification.parentNode) {
                                    document.body.removeChild(notification);
                                }
                            } catch (e) {
                                console.warn('Could not remove notification:', e);
                            }
                        }, 300);
                    }, 5000); // Increased to 5 seconds so you can read error messages
                } catch (error) {
                    console.error('Error showing notification:', error);
                    // Fallback to alert if notification fails
                    alert(`${isSuccess ? 'SUCCESS' : 'ERROR'}: ${message}`);
                }
            }
            
            function openModal(title = 'Add New Content') {
                modalTitle.innerHTML = `<i class="fas fa-plus-circle"></i> ${title}`;
                modal.classList.add('active');
                document.body.style.overflow = 'hidden';
            }
            
            function closeModal() {
                modal.classList.remove('active');
                document.body.style.overflow = '';
                entryForm.reset();
                entryIdInput.value = '';
                currentMovieSources = [];
                renderMovieSources();
                seasonContainerDiv.innerHTML = '';
            }
            
            function resetMovieForm() {
                movieTmdbIdInput.value = '';
                movieTitleInput.value = '';
                movieYearInput.value = '';
                movieDescriptionInput.value = '';
                movieImageInput.value = '';
                movieCoverInput.value = '';
                movieTrailerInput.value = '';
                currentMovieSources = [];
                renderMovieSources();
            }
            
            function resetSeriesForm() {
                seriesTmdbIdInput.value = '';
                seriesTitleInput.value = '';
                seriesYearInput.value = '';
                seriesDescriptionInput.value = '';
                seriesImageInput.value = '';
                seriesCoverInput.value = '';
                seriesTrailerInput.value = '';
                seasonContainerDiv.innerHTML = '';
                currentSeriesData = { seasons: [] };
            }
            
            function resetChannelForm() {
                channelTitleInput.value = '';
                channelImageInput.value = '';
                channelRatingInput.value = '';
                channelCategoryInput.value = '';
                channelDescriptionInput.value = '';
                channelStreamUrlInput.value = '';
                channelBackupUrlInput.value = '';
            }
            
            // --- Data Loading ---
            fileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            loadData(e.target.result);
                            fileInfo.innerHTML = `<i class="fas fa-check-circle"></i> Loaded: ${file.name} (${Math.round(file.size / 1024)} KB)`;
                        } catch (error) {
                            showNotification(`Error parsing JSON: ${error.message}`, false);
                        }
                    };
                    reader.readAsText(file);
                }
            });
            
            loadTextButton.addEventListener('click', () => {
                const text = jsonTextInput.value.trim();
                if (text) {
                    try {
                        loadData(text);
                        showNotification('Data loaded successfully from text!', true);
                    } catch (error) {
                        showNotification(`Error parsing JSON from text: ${error.message}`, false);
                    }
                } else {
                    showNotification('Text area is empty.', false);
                }
            });
            
            // New CineMax API button event listener
            const newCineMaxAPIButton = document.getElementById('newCineMaxAPI');
            if (newCineMaxAPIButton) {
                newCineMaxAPIButton.addEventListener('click', () => {
                    if (jsonData && (jsonData.movies?.length > 0 || jsonData.channels?.length > 0)) {
                        if (confirm('Creating a new API will clear existing data. Are you sure?')) {
                            createNewCineMaxAPI();
                        }
                    } else {
                        createNewCineMaxAPI();
                    }
                });
            }
            
            // Bulk import TMDB button event listener
            const bulkImportButton = document.getElementById('bulkImportTMDB');
            if (bulkImportButton) {
                bulkImportButton.addEventListener('click', async () => {
                    if (!jsonData) {
                        showNotification('Please create a new API or load existing data first', false);
                        return;
                    }
                    
                    const importType = document.getElementById('tmdbBulkType').value;
                    const pages = parseInt(document.getElementById('tmdbBulkPages').value) || 2;
                    
                    await bulkImportFromTMDB(importType, pages);
                });
            }
            
            function loadData(jsonString) {
                try {
                    console.log('Loading JSON data...');
                    console.log('JSON string length:', jsonString.length);
                    
                    jsonData = JSON.parse(jsonString);
                    console.log('Parsed JSON data:', jsonData);
                    
                    if (!jsonData.movies) {
                        console.log('No movies array found, creating empty array');
                        jsonData.movies = [];
                    }
                    if (!jsonData.channels) {
                        console.log('No channels array found, creating empty array');
                        jsonData.channels = [];
                    }
                    
                    // CLEAN EMPTY ENTRIES IMMEDIATELY to prevent crashes
                    console.log('🧹 Cleaning empty entries from loaded data...');
                    jsonData.movies = jsonData.movies.filter(m => m.title && m.title.trim() !== '');
                    jsonData.channels = jsonData.channels.filter(c => c.title && c.title.trim() !== '');
                    
                    if (jsonData.home) {
                        if (jsonData.home.slides) {
                            jsonData.home.slides = jsonData.home.slides.filter(s => s.title && s.title.trim() !== '');
                        }
                        if (jsonData.home.featured_movies) {
                            jsonData.home.featured_movies = jsonData.home.featured_movies.filter(f => f.title && f.title.trim() !== '');
                        }
                    }
                    if (jsonData.actors) {
                        jsonData.actors = jsonData.actors.filter(a => a.name && a.name.trim() !== '');
                    }
                    if (jsonData.genres) {
                        jsonData.genres = jsonData.genres.filter(g => g.title && g.title.trim() !== '');
                    }
                    
                    console.log('Movies count:', jsonData.movies.length);
                    console.log('Channels count:', jsonData.channels.length);
                    
                    // AUTO-GENERATE IMMEDIATELY AFTER LOADING DATA
                    console.log('🔄 Auto-generating related content after data load...');
                    autoGenerateRelatedContent();
                    
                    editorDiv.style.display = 'block';
                    saveSectionDiv.style.display = 'block';
                    renderEntries();
                    
                    // Auto-save the loaded data
                    saveToLocalStorage();
                    
                    const totalItems = (jsonData.movies?.length || 0) + (jsonData.channels?.length || 0);
                    showNotification(`Data loaded successfully! Found ${totalItems} items.`, true);
                    console.log('Data loading completed successfully');
                } catch (error) {
                    console.error('Error loading data:', error);
                    showNotification(`Failed to load data: ${error.message}`, false);
                    throw error;
                }
            }
            
            // --- Render Entries ---
            function renderEntries() {
                if (!jsonData) return;
                
                entryListDiv.innerHTML = '';
                
                // Initialize missing arrays and clean empty entries
                if (!jsonData.home) jsonData.home = {};
                if (!jsonData.home.slides) jsonData.home.slides = [];
                if (!jsonData.home.featured_movies) jsonData.home.featured_movies = [];
                if (!jsonData.actors) jsonData.actors = [];
                if (!jsonData.genres) jsonData.genres = [];
                
                // CLEAN EMPTY/INVALID ENTRIES to prevent crashes
                jsonData.movies = (jsonData.movies || []).filter(m => m.title && m.title.trim() !== '');
                jsonData.channels = (jsonData.channels || []).filter(c => c.title && c.title.trim() !== '');
                jsonData.home.slides = (jsonData.home.slides || []).filter(s => s.title && s.title.trim() !== '');
                jsonData.home.featured_movies = (jsonData.home.featured_movies || []).filter(f => f.title && f.title.trim() !== '');
                jsonData.actors = (jsonData.actors || []).filter(a => a.name && a.name.trim() !== '');
                jsonData.genres = (jsonData.genres || []).filter(g => g.title && g.title.trim() !== '');
                
                console.log('🧹 Cleaned empty entries from JSON data');
                
                const allEntries = [
                    ...(jsonData.movies || []).map(e => ({ ...e, entryType: e.type || (e.seasons ? 'series' : 'movie') })),
                    ...(jsonData.channels || []).map(e => ({ ...e, entryType: 'channel' })),
                    ...(jsonData.home.slides || []).map(e => ({ ...e, entryType: 'slide' })),
                    ...(jsonData.home.featured_movies || []).map(e => ({ ...e, entryType: 'featured' })),
                    ...(jsonData.actors || []).map(e => ({ ...e, entryType: 'actor', title: e.name })),
                    ...(jsonData.genres || []).map(e => ({ ...e, entryType: 'genre' }))
                ];
                
                // Apply filter
                const filteredEntries = currentFilter === 'all' 
                    ? allEntries 
                    : allEntries.filter(entry => 
                        (currentFilter === 'movie' && entry.entryType === 'movie') ||
                        (currentFilter === 'series' && entry.entryType === 'series') ||
                        (currentFilter === 'channel' && entry.entryType === 'channel') ||
                        (currentFilter === 'slides' && entry.entryType === 'slide') ||
                        (currentFilter === 'featured' && entry.entryType === 'featured') ||
                        (currentFilter === 'actors' && entry.entryType === 'actor') ||
                        (currentFilter === 'genres' && entry.entryType === 'genre')
                    );
                
                // Filter out entries with empty titles and sort by title
                const validEntries = filteredEntries.filter(entry => entry.title && entry.title.trim() !== '');
                validEntries.sort((a, b) => a.title.localeCompare(b.title));
                
                if (validEntries.length === 0) {
                    entryListDiv.innerHTML = `
                        <div class="no-results" style="text-align: center; padding: 40px 20px; color: var(--gray);">
                            <i class="fas fa-film" style="font-size: 3rem; margin-bottom: 15px; opacity: 0.5;"></i>
                            <h3 style="margin-bottom: 10px; color: var(--dark);">No content found</h3>
                            <p>Try changing your filter or add new content</p>
                        </div>
                    `;
                    return;
                }
                
                validEntries.forEach(entry => {
                    const typeClass = `type-${entry.entryType}`;
                    const typeLabel = {
                        'movie': 'Movie',
                        'series': 'Series', 
                        'channel': 'Live TV',
                        'slide': 'Slide',
                        'featured': 'Featured',
                        'actor': 'Actor',
                        'genre': 'Genre'
                    }[entry.entryType] || entry.entryType;
                    
                    // Get appropriate metadata based on type
                    let metaInfo = '';
                    if (entry.entryType === 'actor') {
                        metaInfo = `${entry.type || 'Actor'} • ${entry.role || 'N/A'}`;
                    } else if (entry.entryType === 'genre') {
                        const posterCount = entry.posters ? entry.posters.length : 0;
                        metaInfo = `${posterCount} poster${posterCount !== 1 ? 's' : ''}`;
                    } else if (entry.entryType === 'slide') {
                        metaInfo = `Type: ${entry.type || 'N/A'}`;
                    } else {
                        metaInfo = `${entry.year ? `Year: ${entry.year} • ` : ''}${entry.rating ? `Rating: ${entry.rating}/10` : ''}`;
                    }
                    
                    const item = document.createElement('div');
                    item.className = 'entry-item';
                    item.innerHTML = `
                        <div class="entry-item-header">
                            <div class="entry-type ${typeClass}">${typeLabel}</div>
                            <div class="entry-id">#${entry.id}</div>
                        </div>
                        <div class="entry-item-title">${entry.title}</div>
                        <div class="entry-item-meta">
                            ${metaInfo}
                        </div>
                        <div class="entry-item-actions">
                            <button class="edit-btn" data-id="${entry.id}" data-type="${entry.entryType}">
                                <i class="fas fa-edit"></i> Edit
                            </button>
                            <button class="delete-btn" data-id="${entry.id}" data-type="${entry.entryType}">
                                <i class="fas fa-trash"></i> Delete
                            </button>
                        </div>
                    `;
                    entryListDiv.appendChild(item);
                });
            }
            
            // --- Filter Handling ---
            filterButtons.forEach(button => {
                button.addEventListener('click', () => {
                    filterButtons.forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                    currentFilter = button.dataset.filter;
                    renderEntries();
                });
            });
            
            // --- Tab Handling ---
            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const type = button.dataset.type;
                    
                    // Update tabs
                    tabButtons.forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                    
                    // Update content
                    document.querySelectorAll('.category-content').forEach(content => {
                        content.classList.remove('active');
                    });
                    document.querySelector(`.category-content[data-type="${type}"]`).classList.add('active');
                    
                    // Reset forms when switching
                    if (type === 'movie') resetMovieForm();
                    if (type === 'series') resetSeriesForm();
                    if (type === 'channel') resetChannelForm();
                });
            });
            
            // --- CRUD Operations ---
            addNewEntryButton.addEventListener('click', () => {
                openModal('Add New Content');
                resetMovieForm();
                resetSeriesForm();
                resetChannelForm();
            });
            
            entryListDiv.addEventListener('click', (event) => {
                const target = event.target;
                const button = target.closest('button');
                if (!button) return;
                
                const id = button.dataset.id;
                const type = button.dataset.type;
                if (!id || !type) return;
                
                if (button.classList.contains('edit-btn')) {
                    editEntry(id, type);
                } else if (button.classList.contains('delete-btn')) {
                    deleteEntry(id, type);
                }
            });
            
            function editEntry(id, type) {
                let entry;
                if (type === 'channel') {
                    entry = jsonData.channels.find(c => c.id == id);
                } else {
                    entry = jsonData.movies.find(m => m.id == id);
                }
                if (!entry) return;
                
                openModal(`Edit ${type === 'movie' ? 'Movie' : type === 'series' ? 'Series' : 'Live TV'}`);
                entryIdInput.value = entry.id;
                
                // Activate appropriate tab
                const tabType = type === 'channel' ? 'channel' : 
                              (type === 'series' ? 'series' : 'movie');
                document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
                document.querySelector(`.tab-btn[data-type="${tabType}"]`).classList.add('active');
                
                document.querySelectorAll('.category-content').forEach(content => {
                    content.classList.remove('active');
                });
                document.querySelector(`.category-content[data-type="${tabType}"]`).classList.add('active');
                
                if (type === 'channel') {
                    channelTitleInput.value = entry.title || '';
                    channelImageInput.value = entry.image || '';
                    channelRatingInput.value = entry.rating || '';
                    channelCategoryInput.value = entry.category || '';
                    channelDescriptionInput.value = entry.description || '';
                    channelStreamUrlInput.value = entry.sources && entry.sources[0] ? entry.sources[0].url : '';
                    if (entry.sources && entry.sources[1]) {
                        channelBackupUrlInput.value = entry.sources[1].url;
                    }
                } else if (type === 'series') {
                    seriesTitleInput.value = entry.title || '';
                    seriesYearInput.value = entry.year || '';
                    seriesDescriptionInput.value = entry.description || '';
                    seriesImageInput.value = entry.image || '';
                    seriesCoverInput.value = entry.cover || '';
                    seriesTrailerInput.value = entry.trailer ? entry.trailer.url : '';
                    
                    // Render seasons and episodes
                    if (entry.seasons && entry.seasons.length > 0) {
                        currentSeriesData = { ...entry, seasons: entry.seasons };
                        renderSeasons(entry.seasons);
                    }
                } else { // Movie
                    movieTitleInput.value = entry.title || '';
                    movieYearInput.value = entry.year || '';
                    movieDescriptionInput.value = entry.description || '';
                    movieImageInput.value = entry.image || '';
                    movieCoverInput.value = entry.cover || '';
                    movieTrailerInput.value = entry.trailer ? entry.trailer.url : '';
                    
                    currentMovieSources = [...(entry.sources || [])];
                    renderMovieSources();
                }
            }
            
            function deleteEntry(id, type) {
                if (!confirm(`Are you sure you want to delete this ${type}?`)) return;
                
                let index = -1;
                if (type === 'channel') {
                    index = jsonData.channels.findIndex(c => c.id == id);
                    if (index > -1) jsonData.channels.splice(index, 1);
                } else {
                    index = jsonData.movies.findIndex(m => m.id == id);
                    if (index > -1) jsonData.movies.splice(index, 1);
                }
                
                if (index > -1) {
                    showNotification(`${type.charAt(0).toUpperCase() + type.slice(1)} deleted successfully!`, true);
                    renderEntries();
                    // Auto-save after deletion
                    saveToLocalStorage();
                } else {
                    showNotification(`Failed to delete ${type}. Please try again.`, false);
                }
            }
            
            // OLD DUPLICATE FORM HANDLER REMOVED - Using the new one above
            
            function saveMovie(id) {
                console.log('Saving movie with ID:', id);
                console.log('Current movie sources:', currentMovieSources);
                
                const entryData = {
                    type: 'movie',
                    title: movieTitleInput.value.trim(),
                    year: movieYearInput.value.trim(),
                    description: movieDescriptionInput.value.trim(),
                    image: movieImageInput.value.trim(),
                    cover: movieCoverInput.value.trim(),
                    trailer: movieTrailerInput.value.trim() ? { 
                        id: generateNewId(),
                        type: 'video',
                        title: `${movieTitleInput.value.trim()} Trailer`,
                        url: movieTrailerInput.value.trim() 
                    } : null,
                    sources: currentMovieSources.length > 0 ? currentMovieSources : [],
                    label: 'Movie',
                    sublabel: movieYearInput.value.trim() || 'N/A',
                    imdb: '0.0',
                    downloadas: movieTitleInput.value.trim().toLowerCase().replace(/[^a-z0-9]/g, '-'),
                    comment: true,
                    playas: 'video',
                    classification: 'N/A',
                    duration: '00:00',
                    rating: 0,
                    views: 0,
                    downloads: 0,
                    shares: 0,
                    created_at: new Date().toISOString().split('T')[0],
                    genres: currentMovieGenres.length > 0 ? currentMovieGenres : [],
                    actors: [],
                    subtitles: [],
                    comments: []
                };
                
                console.log('Movie data to save:', entryData);
                
                if (id) {
                    const index = jsonData.movies.findIndex(m => m.id == id);
                    if (index > -1) {
                        jsonData.movies[index] = { ...jsonData.movies[index], ...entryData };
                        console.log('Updated existing movie at index:', index);
                    }
                } else {
                    const newId = generateNewId();
                    jsonData.movies.push({ id: newId, ...entryData });
                    console.log('Added new movie with ID:', newId);
                }
                
                console.log('Total movies after save:', jsonData.movies.length);
            }
            
            function saveSeries(id) {
                // Collect season/episode data from the form
                const seasons = [];
                const seasonElements = document.querySelectorAll('.season-card');
                
                for (const seasonElement of seasonElements) {
                    const seasonNumber = parseInt(seasonElement.dataset.season);
                    const episodes = [];
                    const episodeElements = seasonElement.querySelectorAll('.episode-item');
                    
                    for (const episodeElement of episodeElements) {
                        const episodeNumber = parseInt(episodeElement.dataset.episode);
                        const sourceUrl = episodeElement.querySelector('.episode-sources input').value.trim();
                        
                        if (sourceUrl) {
                            const titleElement = episodeElement.querySelector('.episode-title');
                            const episodeTitle = titleElement ? titleElement.textContent.replace(/^Episode \d+: /, '') : `Episode ${episodeNumber}`;
                            
                            episodes.push({
                                id: generateNewId(),
                                title: episodeTitle,
                                episode_number: episodeNumber,
                                image: '',
                                duration: '45:00',
                                views: 0,
                                downloads: 0,
                                sources: [{ 
                                    id: generateNewId(),
                                    type: 'video', 
                                    title: `${episodeTitle} 1080p`,
                                    quality: '1080p',
                                    url: sourceUrl 
                                }],
                                subtitles: []
                            });
                        }
                    }
                    
                    if (episodes.length > 0) {
                        seasons.push({
                            id: generateNewId(),
                            title: `Season ${seasonNumber}`,
                            episodes: episodes
                        });
                    }
                }
                
                const entryData = {
                    type: 'series',
                    title: seriesTitleInput.value.trim(),
                    year: seriesYearInput.value.trim(),
                    description: seriesDescriptionInput.value.trim(),
                    image: seriesImageInput.value.trim(),
                    cover: seriesCoverInput.value.trim(),
                    trailer: seriesTrailerInput.value.trim() ? { 
                        id: generateNewId(),
                        type: 'video',
                        title: `${seriesTitleInput.value.trim()} Trailer`,
                        url: seriesTrailerInput.value.trim() 
                    } : null,
                    label: 'Series',
                    sublabel: `${seasons.length} Season${seasons.length !== 1 ? 's' : ''}`,
                    imdb: '0.0',
                    downloadas: seriesTitleInput.value.trim().toLowerCase().replace(/[^a-z0-9]/g, '-'),
                    comment: true,
                    playas: 'video',
                    classification: 'TV-PG',
                    duration: '45:00',
                    rating: 0,
                    views: 0,
                    downloads: 0,
                    shares: 0,
                    created_at: new Date().toISOString().split('T')[0],
                    genres: [],
                    actors: [],
                    subtitles: [],
                    comments: [],
                    sources: [],
                    seasons: seasons
                };
                
                if (id) {
                    const index = jsonData.movies.findIndex(m => m.id == id);
                    if (index > -1) {
                        jsonData.movies[index] = { ...jsonData.movies[index], ...entryData };
                    }
                } else {
                    const newId = generateNewId();
                    jsonData.movies.push({ id: newId, ...entryData });
                }
            }
            
            function saveChannel(id) {
                const sources = [];
                if (channelStreamUrlInput.value.trim()) {
                    sources.push({ 
                        id: generateNewId(),
                        type: 'live',
                        title: 'Live Stream',
                        quality: 'HD',
                        size: 'Live',
                        kind: 'play',
                        premium: 'false',
                        external: false,
                        url: channelStreamUrlInput.value.trim() 
                    });
                }
                if (channelBackupUrlInput.value.trim()) {
                    sources.push({ 
                        id: generateNewId(),
                        type: 'live',
                        title: 'Backup Stream',
                        quality: 'HD',
                        size: 'Live',
                        kind: 'play',
                        premium: 'false',
                        external: false,
                        url: channelBackupUrlInput.value.trim() 
                    });
                }
                
                const categoryTitle = channelCategoryInput.value.trim() || 'General';
                
                const entryData = {
                    title: channelTitleInput.value.trim(),
                    label: categoryTitle,
                    sublabel: 'Live TV',
                    description: channelDescriptionInput.value.trim(),
                    website: 'https://example.com',
                    classification: categoryTitle,
                    views: 0,
                    shares: 0,
                    rating: parseFloat(channelRatingInput.value) || 0,
                    comment: true,
                    image: channelImageInput.value.trim(),
                    playas: 'live',
                    sources: sources,
                    categories: [{
                        id: generateNewId(),
                        title: categoryTitle
                    }],
                    countries: [{
                        id: 1,
                        title: 'US'
                    }],
                    comments: []
                };
                
                if (id) {
                    const index = jsonData.channels.findIndex(c => c.id == id);
                    if (index > -1) {
                        jsonData.channels[index] = { ...jsonData.channels[index], ...entryData };
                    }
                } else {
                    const newId = generateNewId();
                    jsonData.channels.push({ id: newId, ...entryData });
                }
            }
            
            function generateNewId() {
                const allIds = [
                    ...(jsonData.movies || []).map(m => m.id),
                    ...(jsonData.channels || []).map(c => c.id),
                    // Also check for IDs in sources, episodes, etc.
                    ...getAllNestedIds()
                ];
                return allIds.length > 0 ? Math.max(...allIds) + 1 : 1;
            }
            
            function getAllNestedIds() {
                const ids = [];
                
                // Collect IDs from movie sources
                if (jsonData.movies) {
                    jsonData.movies.forEach(movie => {
                        if (movie.sources) {
                            movie.sources.forEach(source => {
                                if (source.id) ids.push(source.id);
                            });
                        }
                        if (movie.seasons) {
                            movie.seasons.forEach(season => {
                                if (season.id) ids.push(season.id);
                                if (season.episodes) {
                                    season.episodes.forEach(episode => {
                                        if (episode.id) ids.push(episode.id);
                                        if (episode.sources) {
                                            episode.sources.forEach(source => {
                                                if (source.id) ids.push(source.id);
                                            });
                                        }
                                    });
                                }
                            });
                        }
                    });
                }
                
                // Collect IDs from channel sources
                if (jsonData.channels) {
                    jsonData.channels.forEach(channel => {
                        if (channel.sources) {
                            channel.sources.forEach(source => {
                                if (source.id) ids.push(source.id);
                            });
                        }
                    });
                }
                
                return ids;
            }
            
            // --- Movie Source Management ---
            function renderMovieSources() {
                movieSourceListDiv.innerHTML = '';
                if (currentMovieSources.length === 0) {
                    movieSourceListDiv.innerHTML = '<div class="no-sources">No sources added yet</div>';
                    return;
                }
                
                currentMovieSources.forEach((source, index) => {
                    const item = document.createElement('div');
                    item.className = 'source-item';
                    item.innerHTML = `
                        <span>${source.title || 'Source'}: ${source.url}</span>
                        <button class="remove-source-btn" data-index="${index}">&times;</button>
                    `;
                    movieSourceListDiv.appendChild(item);
                });
            }
            
            addMovieSourceButton.addEventListener('click', () => {
                const name = movieSourceNameInput.value.trim() || 'Source';
                const url = movieSourceUrlInput.value.trim();
                if (url) {
                    currentMovieSources.push({ 
                        id: generateNewId(),
                        type: 'video',
                        title: name,
                        quality: name.includes('1080') ? '1080p' : name.includes('720') ? '720p' : name.includes('480') ? '480p' : 'HD',
                        size: '0MB',
                        kind: 'both',
                        premium: 'false',
                        external: false,
                        url: url 
                    });
                    movieSourceNameInput.value = '';
                    movieSourceUrlInput.value = '';
                    renderMovieSources();
                }
            });
            
            movieSourceListDiv.addEventListener('click', (event) => {
                if (event.target.classList.contains('remove-source-btn')) {
                    const index = parseInt(event.target.dataset.index, 10);
                    currentMovieSources.splice(index, 1);
                    renderMovieSources();
                }
            });
            
            // --- Series Season/Episode Management ---
            async function renderSeasons(seasonsData) {
                seasonContainerDiv.innerHTML = '';
                
                if (!seasonsData || seasonsData.length === 0) {
                    // Add default season if none exist
                    seasonContainerDiv.innerHTML = `
                        <div class="no-seasons">
                            <p>No seasons configured. <button type="button" id="addSeasonButton" style="margin-left: 10px; padding: 5px 10px;">Add Season 1</button></p>
                        </div>
                    `;
                    
                    document.getElementById('addSeasonButton').addEventListener('click', () => {
                        const newSeason = {
                            id: generateNewId(),
                            title: 'Season 1',
                            episodes: [{
                                id: generateNewId(),
                                title: 'Episode 1',
                                episode_number: 1,
                                image: '',
                                duration: '45:00',
                                views: 0,
                                downloads: 0,
                                sources: [],
                                subtitles: []
                            }]
                        };
                        renderSeasons([newSeason]);
                    });
                    return;
                }
                
                for (let seasonIndex = 0; seasonIndex < seasonsData.length; seasonIndex++) {
                    const season = seasonsData[seasonIndex];
                    const seasonNumber = seasonIndex + 1;
                    const seasonCard = document.createElement('div');
                    seasonCard.className = 'season-card';
                    seasonCard.dataset.season = seasonNumber;
                    seasonCard.innerHTML = `
                        <div class="season-header">
                            <h3>${season.title || `Season ${seasonNumber}`}</h3>
                            <div>
                                <span>${season.episodes.length} episodes</span>
                                <button type="button" class="add-episode-btn" data-season="${seasonNumber}" style="margin-left: 10px; padding: 5px 10px; font-size: 12px;">Add Episode</button>
                            </div>
                        </div>
                        <div class="episode-list"></div>
                    `;
                    
                    const episodeList = seasonCard.querySelector('.episode-list');
                    for (let episodeIndex = 0; episodeIndex < season.episodes.length; episodeIndex++) {
                        const episode = season.episodes[episodeIndex];
                        const episodeNumber = episodeIndex + 1;
                        const episodeItem = document.createElement('div');
                        episodeItem.className = 'episode-item';
                        episodeItem.dataset.episode = episodeNumber;
                        episodeItem.innerHTML = `
                            <div class="episode-header">
                                <div class="episode-title">Episode ${episodeNumber}: ${episode.title || `Episode ${episodeNumber}`}</div>
                                <div class="episode-meta">${episode.sources?.length || 0} source(s)</div>
                            </div>
                            <div class="episode-sources">
                                <input type="text" class="episode-source-input" 
                                       value="${episode.sources?.[0]?.url || ''}" 
                                       placeholder="Episode source URL">
                            </div>
                        `;
                        episodeList.appendChild(episodeItem);
                    }
                    
                    seasonContainerDiv.appendChild(seasonCard);
                }
                
                // Add event listeners for adding episodes
                document.querySelectorAll('.add-episode-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const seasonNumber = parseInt(e.target.dataset.season);
                        const seasonIndex = seasonNumber - 1;
                        const season = seasonsData[seasonIndex];
                        const newEpisodeNumber = season.episodes.length + 1;
                        
                        season.episodes.push({
                            id: generateNewId(),
                            title: `Episode ${newEpisodeNumber}`,
                            episode_number: newEpisodeNumber,
                            image: '',
                            duration: '45:00',
                            views: 0,
                            downloads: 0,
                            sources: [],
                            subtitles: []
                        });
                        
                        renderSeasons(seasonsData);
                    });
                });
            }
            
            // --- TMDb Integration ---
            async function fetchTMDbData(type, tmdbId) {
                const baseUrl = 'https://api.themoviedb.org/3';
                let endpoint = '';
                
                if (type === 'movie') {
                    endpoint = `movie/${tmdbId}`;
                } else if (type === 'series') {
                    endpoint = `tv/${tmdbId}`;
                } else {
                    throw new Error('Invalid content type');
                }
                
                const url = `${baseUrl}/${endpoint}?api_key=${tmdbApiKey}`;
                const res = await fetch(url);
                
                if (!res.ok) {
                    throw new Error(`Failed to fetch ${type} data: ${res.statusText}`);
                }
                
                return await res.json();
            }
            
            async function fetchSeriesDetails(tmdbId) {
                const seriesData = await fetchTMDbData('series', tmdbId);
                
                // Fetch trailer
                const videosUrl = `https://api.themoviedb.org/3/tv/${tmdbId}/videos?api_key=${tmdbApiKey}`;
                const videosRes = await fetch(videosUrl);
                const videosData = videosRes.ok ? await videosRes.json() : { results: [] };
                const trailer = videosData.results.find(v => v.site === 'YouTube' && v.type === 'Trailer');
                
                return {
                    ...seriesData,
                    trailer: trailer ? `https://www.youtube.com/watch?v=${trailer.key}` : ''
                };
            }

            // Bulk Import from TMDB
            async function bulkImportFromTMDB(importType, pages) {
                const progressDiv = document.getElementById('bulkImportProgress');
                const progressBar = document.getElementById('bulkImportProgressBar');
                const statusText = document.getElementById('bulkImportStatus');
                
                progressDiv.style.display = 'block';
                progressBar.style.width = '0%';
                statusText.textContent = 'Starting bulk import...';
                
                try {
                    let endpoint = '';
                    let isTV = false;
                    
                    switch (importType) {
                        case 'popular-movies':
                            endpoint = 'movie/popular';
                            break;
                        case 'top-rated-movies':
                            endpoint = 'movie/top_rated';
                            break;
                        case 'upcoming-movies':
                            endpoint = 'movie/upcoming';
                            break;
                        case 'now-playing-movies':
                            endpoint = 'movie/now_playing';
                            break;
                        case 'popular-tv':
                            endpoint = 'tv/popular';
                            isTV = true;
                            break;
                        case 'top-rated-tv':
                            endpoint = 'tv/top_rated';
                            isTV = true;
                            break;
                    }
                    
                    let totalItems = 0;
                    let processedItems = 0;
                    let addedItems = 0;
                    
                    // Fetch all pages first to calculate total
                    statusText.textContent = 'Fetching data from TMDB...';
                    const allResults = [];
                    
                    for (let page = 1; page <= pages; page++) {
                        const url = `https://api.themoviedb.org/3/${endpoint}?api_key=${tmdbApiKey}&page=${page}`;
                        const response = await fetch(url);
                        
                        if (!response.ok) {
                            throw new Error(`Failed to fetch page ${page}: ${response.statusText}`);
                        }
                        
                        const data = await response.json();
                        allResults.push(...data.results);
                        
                        // Update progress for fetching
                        const fetchProgress = (page / pages) * 30; // 30% for fetching
                        progressBar.style.width = `${fetchProgress}%`;
                        statusText.textContent = `Fetching page ${page} of ${pages}...`;
                        
                        // Rate limiting - TMDB allows 40 requests per 10 seconds
                        if (page < pages) {
                            await new Promise(resolve => setTimeout(resolve, 300));
                        }
                    }
                    
                    totalItems = allResults.length;
                    statusText.textContent = `Processing ${totalItems} items...`;
                    
                    // Process each item
                    for (const item of allResults) {
                        try {
                            let movieData;
                            
                            if (isTV) {
                                // For TV shows, get detailed data
                                const detailsResponse = await fetch(`https://api.themoviedb.org/3/tv/${item.id}?api_key=${tmdbApiKey}`);
                                if (detailsResponse.ok) {
                                    const details = await detailsResponse.json();
                                    
                                    // Get credits
                                    const creditsResponse = await fetch(`https://api.themoviedb.org/3/tv/${item.id}/credits?api_key=${tmdbApiKey}`);
                                    const credits = creditsResponse.ok ? await creditsResponse.json() : { cast: [], crew: [] };
                                    
                                    // Get trailer
                                    const videosResponse = await fetch(`https://api.themoviedb.org/3/tv/${item.id}/videos?api_key=${tmdbApiKey}`);
                                    const videos = videosResponse.ok ? await videosResponse.json() : { results: [] };
                                    const trailer = videos.results.find(v => v.site === 'YouTube' && v.type === 'Trailer');
                                    
                                    movieData = createCineMaxSeriesFromTMDB(details, credits, trailer);
                                }
                            } else {
                                // For movies, get detailed data
                                const detailsResponse = await fetch(`https://api.themoviedb.org/3/movie/${item.id}?api_key=${tmdbApiKey}`);
                                if (detailsResponse.ok) {
                                    const details = await detailsResponse.json();
                                    
                                    // Get credits
                                    const creditsResponse = await fetch(`https://api.themoviedb.org/3/movie/${item.id}/credits?api_key=${tmdbApiKey}`);
                                    const credits = creditsResponse.ok ? await creditsResponse.json() : { cast: [], crew: [] };
                                    
                                    // Get trailer
                                    const videosResponse = await fetch(`https://api.themoviedb.org/3/movie/${item.id}/videos?api_key=${tmdbApiKey}`);
                                    const videos = videosResponse.ok ? await videosResponse.json() : { results: [] };
                                    const trailer = videos.results.find(v => v.site === 'YouTube' && v.type === 'Trailer');
                                    
                                    movieData = createCineMaxMovieFromTMDB(details, credits, trailer);
                                }
                            }
                            
                            if (movieData) {
                                // Check if already exists
                                const existingMovie = jsonData.movies.find(m => 
                                    m.title.toLowerCase() === movieData.title.toLowerCase() && 
                                    m.year === movieData.year
                                );
                                
                                if (!existingMovie) {
                                    jsonData.movies.push(movieData);
                                    addedItems++;
                                }
                            }
                            
                            processedItems++;
                            const progress = 30 + (processedItems / totalItems) * 70; // 70% for processing
                            progressBar.style.width = `${progress}%`;
                            statusText.textContent = `Processed ${processedItems}/${totalItems} items (${addedItems} added)`;
                            
                            // Rate limiting
                            if (processedItems % 5 === 0) {
                                await new Promise(resolve => setTimeout(resolve, 1000));
                            }
                            
                        } catch (error) {
                            console.warn(`Failed to process item ${item.id}:`, error);
                        }
                    }
                    
                    // Update API info
                    if (jsonData.api_info) {
                        jsonData.api_info.total_movies = jsonData.movies.length;
                        jsonData.api_info.last_updated = new Date().toISOString().split('T')[0];
                    }
                    
                    // Auto-generate related content
                    if (autoGenerationEnabled) {
                        autoGenerateRelatedContent();
                    }
                    
                    // Update UI
                    renderEntries();
                    
                    // Auto-save the imported data
                    saveToLocalStorage();
                    
                    progressBar.style.width = '100%';
                    statusText.textContent = `✅ Bulk import completed! Added ${addedItems} new items out of ${totalItems} processed.`;
                    showNotification(`Bulk import completed! Added ${addedItems} new items.`, true);
                    
                    // Hide progress after 3 seconds
                    setTimeout(() => {
                        progressDiv.style.display = 'none';
                    }, 3000);
                    
                } catch (error) {
                    console.error('Bulk import error:', error);
                    statusText.textContent = `❌ Error: ${error.message}`;
                    showNotification(`Bulk import failed: ${error.message}`, false);
                }
            }

            function createCineMaxMovieFromTMDB(movieData, credits, trailer) {
                const newId = generateNewId();
                
                // Get top 5 actors
                const actors = credits.cast.slice(0, 5).map(actor => ({
                    id: generateNewId(),
                    name: actor.name,
                    type: 'actor',
                    role: actor.character || 'Actor',
                    image: actor.profile_path ? `https://image.tmdb.org/t/p/w200${actor.profile_path}` : '',
                    born: '',
                    height: '',
                    bio: ''
                }));
                
                // Add director
                const director = credits.crew.find(person => person.job === 'Director');
                if (director) {
                    actors.push({
                        id: generateNewId(),
                        name: director.name,
                        type: 'director',
                        role: 'Director',
                        image: director.profile_path ? `https://image.tmdb.org/t/p/w200${director.profile_path}` : '',
                        born: '',
                        height: '',
                        bio: ''
                    });
                }
                
                return {
                    id: newId,
                    type: 'movie',
                    title: movieData.title,
                    year: movieData.release_date ? movieData.release_date.split('-')[0] : 'N/A',
                    description: movieData.overview || '',
                    image: movieData.poster_path ? `https://image.tmdb.org/t/p/w500${movieData.poster_path}` : '',
                    cover: movieData.backdrop_path ? `https://image.tmdb.org/t/p/original${movieData.backdrop_path}` : '',
                    trailer: trailer ? {
                        id: generateNewId(),
                        type: 'video',
                        title: `${movieData.title} Trailer`,
                        url: `https://www.youtube.com/watch?v=${trailer.key}`
                    } : null,
                    sources: [{
                        id: generateNewId(),
                        type: 'video',
                        title: 'vidsrc.net 1080p',
                        quality: '1080p',
                        size: '0MB',
                        kind: 'both',
                        premium: 'false',
                        external: false,
                        url: `https://vidsrc.net/embed/movie/${movieData.id}`
                    }],
                    label: 'Movie',
                    sublabel: movieData.release_date ? movieData.release_date.split('-')[0] : 'N/A',
                    imdb: movieData.vote_average ? movieData.vote_average.toString() : '0.0',
                    downloadas: movieData.title.toLowerCase().replace(/[^a-z0-9]/g, '-'),
                    comment: true,
                    playas: 'video',
                    classification: movieData.adult ? 'R' : 'PG-13',
                    duration: movieData.runtime ? `${Math.floor(movieData.runtime / 60)}:${(movieData.runtime % 60).toString().padStart(2, '0')}` : '00:00',
                    rating: movieData.vote_average || 0,
                    created_at: new Date().toISOString().split('T')[0],
                    genres: (movieData.genres || []).map(g => ({
                        id: g.id,
                        name: g.name || g.title  // Ensure "name" field for movie genres
                    })),
                    actors: actors,
                    subtitles: [],
                    comments: []
                };
            }

            function createCineMaxSeriesFromTMDB(seriesData, credits, trailer) {
                const newId = generateNewId();
                
                // Get top 5 actors
                const actors = credits.cast.slice(0, 5).map(actor => ({
                    id: generateNewId(),
                    name: actor.name,
                    type: 'actor',
                    role: actor.character || 'Actor',
                    image: actor.profile_path ? `https://image.tmdb.org/t/p/w200${actor.profile_path}` : '',
                    born: '',
                    height: '',
                    bio: ''
                }));
                
                // Add creator as director
                if (seriesData.created_by && seriesData.created_by.length > 0) {
                    const creator = seriesData.created_by[0];
                    actors.push({
                        id: generateNewId(),
                        name: creator.name,
                        type: 'director',
                        role: 'Creator',
                        image: creator.profile_path ? `https://image.tmdb.org/t/p/w200${creator.profile_path}` : '',
                        born: '',
                        height: '',
                        bio: ''
                    });
                }
                
                return {
                    id: newId,
                    type: 'series',
                    title: seriesData.name,
                    year: seriesData.first_air_date ? seriesData.first_air_date.split('-')[0] : 'N/A',
                    description: seriesData.overview || '',
                    image: seriesData.poster_path ? `https://image.tmdb.org/t/p/w500${seriesData.poster_path}` : '',
                    cover: seriesData.backdrop_path ? `https://image.tmdb.org/t/p/original${seriesData.backdrop_path}` : '',
                    trailer: trailer ? {
                        id: generateNewId(),
                        type: 'video',
                        title: `${seriesData.name} Trailer`,
                        url: `https://www.youtube.com/watch?v=${trailer.key}`
                    } : null,
                    label: 'Series',
                    sublabel: seriesData.first_air_date ? seriesData.first_air_date.split('-')[0] : 'N/A',
                    imdb: seriesData.vote_average ? seriesData.vote_average.toString() : '0.0',
                    downloadas: seriesData.name.toLowerCase().replace(/[^a-z0-9]/g, '-'),
                    comment: true,
                    playas: 'video',
                    classification: seriesData.adult ? 'R' : 'PG-13',
                    duration: '00:00',
                    rating: seriesData.vote_average || 0,
                    created_at: new Date().toISOString().split('T')[0],
                    genres: (seriesData.genres || []).map(g => ({
                        id: g.id,
                        name: g.name || g.title  // Ensure "name" field for series genres
                    })),
                    actors: actors,
                    subtitles: [],
                    comments: [],
                    sources: [],
                    seasons: [] // This would need to be populated separately if needed
                };
            }
            
            fetchMovieTMDbButton.addEventListener('click', async () => {
                const tmdbId = movieTmdbIdInput.value.trim();
                if (!tmdbId) {
                    showNotification('Please enter a TMDb Movie ID', false);
                    return;
                }
                
                try {
                    const movieData = await fetchTMDbData('movie', tmdbId);
                    
                    // Populate form
                    movieTitleInput.value = movieData.title;
                    movieYearInput.value = movieData.release_date ? movieData.release_date.split('-')[0] : '';
                    movieDescriptionInput.value = movieData.overview || '';
                    movieImageInput.value = movieData.poster_path ? 
                        `https://image.tmdb.org/t/p/w500${movieData.poster_path}` : '';
                    movieCoverInput.value = movieData.backdrop_path ? 
                        `https://image.tmdb.org/t/p/original${movieData.backdrop_path}` : '';
                    
                    // Auto-add genres from TMDb (convert to CineMax format)
                    currentMovieGenres = (movieData.genres || []).map(genre => ({
                        id: genre.id,
                        name: genre.name || genre.title  // Ensure "name" field for movie genres
                    }));
                    console.log('Auto-added genres:', currentMovieGenres);
                    
                    // Auto-add actors from TMDb credits
                    try {
                        const creditsUrl = `https://api.themoviedb.org/3/movie/${tmdbId}/credits?api_key=${tmdbApiKey}`;
                        const creditsRes = await fetch(creditsUrl);
                        const creditsData = creditsRes.ok ? await creditsRes.json() : { cast: [], crew: [] };
                        
                        // Add top 5 cast members as actors
                        const topActors = creditsData.cast.slice(0, 5).map(actor => ({
                            name: actor.name,
                            type: 'actor',
                            role: actor.character || 'Actor',
                            image: actor.profile_path ? `https://image.tmdb.org/t/p/w200${actor.profile_path}` : ''
                        }));
                        
                        // Add director from crew
                        const director = creditsData.crew.find(person => person.job === 'Director');
                        if (director) {
                            topActors.push({
                                name: director.name,
                                type: 'director',
                                role: 'Director',
                                image: director.profile_path ? `https://image.tmdb.org/t/p/w200${director.profile_path}` : ''
                            });
                        }
                        
                        // Update current movie actors
                        currentMovieActors = topActors;
                        console.log('Auto-added actors from TMDb:', currentMovieActors);
                    } catch (error) {
                        console.warn('Could not fetch credits:', error);
                    }
                    
                    // Fetch trailer
                    const videosUrl = `https://api.themoviedb.org/3/movie/${tmdbId}/videos?api_key=${tmdbApiKey}`;
                    const videosRes = await fetch(videosUrl);
                    const videosData = videosRes.ok ? await videosRes.json() : { results: [] };
                    const trailer = videosData.results.find(v => v.site === 'YouTube' && v.type === 'Trailer');
                    movieTrailerInput.value = trailer ? `https://www.youtube.com/watch?v=${trailer.key}` : '';
                    
                    // Auto-add vidsrc source
                    const vidsrcUrl = `https://vidsrc.net/embed/movie/${tmdbId}`;
                    currentMovieSources = [{ 
                        id: generateNewId(),
                        type: 'video',
                        title: 'vidsrc.net 1080p',
                        quality: '1080p',
                        size: '0MB',
                        kind: 'both',
                        premium: 'false',
                        external: false,
                        url: vidsrcUrl 
                    }];
                    renderMovieSources();
                    
                    // Auto-generate related content after TMDB fetch
                    console.log('🔄 Auto-generating related content after TMDB movie fetch...');
                    showNotification('Fetching movie data and generating related content...', true);
                    
                    setTimeout(() => {
                        autoGenerateRelatedContent();
                        renderEntries();
                        showNotification(`✅ Movie "${movieData.title}" added with auto-generated slides, featured, actors, and genres!`, true);
                    }, 500);
                } catch (error) {
                    showNotification(`Error: ${error.message}`, false);
                }
            });
            
            fetchSeriesTMDbButton.addEventListener('click', async () => {
                const tmdbId = seriesTmdbIdInput.value.trim();
                if (!tmdbId) {
                    showNotification('Please enter a TMDb Series ID', false);
                    return;
                }
                
                try {
                    const seriesData = await fetchSeriesDetails(tmdbId);
                    
                    // Populate form
                    seriesTitleInput.value = seriesData.name;
                    seriesYearInput.value = seriesData.first_air_date ? seriesData.first_air_date.split('-')[0] : '';
                    seriesDescriptionInput.value = seriesData.overview || '';
                    seriesImageInput.value = seriesData.poster_path ? 
                        `https://image.tmdb.org/t/p/w500${seriesData.poster_path}` : '';
                    seriesCoverInput.value = seriesData.backdrop_path ? 
                        `https://image.tmdb.org/t/p/original${seriesData.backdrop_path}` : '';
                    seriesTrailerInput.value = seriesData.trailer || '';
                    
                    // Auto-add genres from TMDb
                    currentSeriesGenres = seriesData.genres || [];
                    console.log('Auto-added series genres:', currentSeriesGenres);
                    
                    // Auto-add actors from TMDb credits
                    try {
                        const creditsUrl = `https://api.themoviedb.org/3/tv/${tmdbId}/credits?api_key=${tmdbApiKey}`;
                        const creditsRes = await fetch(creditsUrl);
                        const creditsData = creditsRes.ok ? await creditsRes.json() : { cast: [], crew: [] };
                        
                        // Add top 5 cast members as actors
                        const topActors = creditsData.cast.slice(0, 5).map(actor => ({
                            name: actor.name,
                            type: 'actor',
                            role: actor.character || 'Actor',
                            image: actor.profile_path ? `https://image.tmdb.org/t/p/w200${actor.profile_path}` : ''
                        }));
                        
                        // Add creator from crew
                        const creator = creditsData.crew.find(person => person.job === 'Creator');
                        if (creator) {
                            topActors.push({
                                name: creator.name,
                                type: 'creator',
                                role: 'Creator',
                                image: creator.profile_path ? `https://image.tmdb.org/t/p/w200${creator.profile_path}` : ''
                            });
                        }
                        
                        // Update current series actors
                        currentSeriesActors = topActors;
                        console.log('Auto-added series actors from TMDb:', currentSeriesActors);
                    } catch (error) {
                        console.warn('Could not fetch series credits:', error);
                    }
                    
                    // Prepare seasons data with auto vidsrc URLs
                    currentSeriesData = {
                        ...seriesData,
                        seasons: seriesData.seasons.filter(s => s.season_number > 0).map(season => ({
                            id: generateNewId(),
                            title: `Season ${season.season_number}`,
                            episodes: Array.from({length: season.episode_count || 1}, (_, i) => {
                                const episodeNumber = i + 1;
                                const vidsrcEpisodeUrl = `https://vidsrc.net/embed/tv/${tmdbId}/${season.season_number}/${episodeNumber}`;
                                return {
                                    id: generateNewId(),
                                    title: `Episode ${episodeNumber}`,
                                    episode_number: episodeNumber,
                                    image: '',
                                    duration: '45:00',
                                    views: 0,
                                    downloads: 0,
                                    sources: [{
                                        id: generateNewId(),
                                        type: 'video',
                                        title: `Episode ${episodeNumber} 1080p`,
                                        quality: '1080p',
                                        url: vidsrcEpisodeUrl
                                    }],
                                    subtitles: []
                                };
                            })
                        }))
                    };
                    
                    // Render seasons
                    renderSeasons(currentSeriesData.seasons);
                    
                    // Auto-generate related content after TMDB fetch
                    console.log('🔄 Auto-generating related content after TMDB series fetch...');
                    showNotification('Fetching series data and generating related content...', true);
                    
                    setTimeout(() => {
                        autoGenerateRelatedContent();
                        renderEntries();
                        showNotification(`✅ Series "${seriesData.name}" added with auto-generated slides, featured, actors, and genres!`, true);
                    }, 500);
                } catch (error) {
                    showNotification(`Error: ${error.message}`, false);
                }
            });
            
            // --- Save and Download ---
            saveButton.addEventListener('click', () => {
                if (!jsonData) {
                    showNotification('No data to save', false);
                    return;
                }
                
                // Prepare final CineMax API format
                const cineMaxAPI = prepareCineMaxAPIFormat();
                
                const jsonString = JSON.stringify(cineMaxAPI, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'free_movie_api.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showNotification('CineMax API downloaded successfully!', true);
            });
            
            // Add validation button event listener
            const validateButton = document.getElementById('validateButton');
            if (validateButton) {
                validateButton.addEventListener('click', () => {
                    if (!jsonData) {
                        showNotification('No data to validate', false);
                        return;
                    }
                    
                    validateCineMaxAPI();
                });
            }
            
            function prepareCineMaxAPIFormat() {
                // Update API info with current stats
                const updatedApiInfo = {
                    ...jsonData.api_info,
                    total_movies: jsonData.movies?.length || 0,
                    total_channels: jsonData.channels?.length || 0,
                    total_actors: jsonData.actors?.length || 0,
                    last_updated: new Date().toISOString().split('T')[0]
                };
                
                // Ensure all movies have complete CineMax structure
                const processedMovies = (jsonData.movies || []).map(movie => ({
                    id: movie.id,
                    type: movie.type || 'movie',
                    title: movie.title,
                    year: movie.year,
                    description: movie.description || '',
                    image: movie.image || '',
                    cover: movie.cover || movie.image || '',
                    trailer: movie.trailer,
                    sources: movie.sources || [],
                    label: movie.label || (movie.type === 'series' ? 'Series' : 'Movie'),
                    sublabel: movie.sublabel || movie.year || 'N/A',
                    imdb: movie.imdb || '0.0',
                    downloadas: movie.downloadas || movie.title?.toLowerCase().replace(/[^a-z0-9]/g, '-') || '',
                    comment: movie.comment !== undefined ? movie.comment : true,
                    playas: movie.playas || 'video',
                    classification: movie.classification || 'PG-13',
                    duration: movie.duration || '00:00',
                    rating: movie.rating || 0,
                    created_at: movie.created_at || new Date().toISOString().split('T')[0],
                    genres: movie.genres || [],
                    actors: movie.actors || [],
                    subtitles: movie.subtitles || [],
                    comments: movie.comments || [],
                    views: movie.views || 0,
                    downloads: movie.downloads || 0,
                    shares: movie.shares || 0,
                    ...(movie.type === 'series' && { seasons: movie.seasons || [] })
                }));
                
                // Ensure all channels have complete CineMax structure
                const processedChannels = (jsonData.channels || []).map(channel => ({
                    id: channel.id,
                    title: channel.title,
                    label: channel.label || channel.category || 'Entertainment',
                    sublabel: channel.sublabel || 'Live TV',
                    description: channel.description || '',
                    website: channel.website || 'https://example.com',
                    classification: channel.classification || channel.category || 'Entertainment',
                    views: channel.views || 0,
                    shares: channel.shares || 0,
                    rating: channel.rating || 0,
                    comment: channel.comment !== undefined ? channel.comment : true,
                    image: channel.image || '',
                    playas: channel.playas || 'live',
                    sources: channel.sources || [],
                    categories: channel.categories || [{
                        id: 1,
                        title: channel.label || channel.category || 'Entertainment'
                    }],
                    countries: channel.countries || [{
                        id: 1,
                        title: 'US'
                    }],
                    comments: channel.comments || []
                }));
                
                // Build home slides from movies and channels
                const homeSlides = [];
                
                // Add slides from existing slides
                if (jsonData.home?.slides) {
                    homeSlides.push(...jsonData.home.slides);
                }
                
                // Add top movies as slides if not enough slides
                if (homeSlides.length < 5) {
                    const topMovies = processedMovies
                        .filter(m => m.rating > 7)
                        .sort((a, b) => b.rating - a.rating)
                        .slice(0, 5 - homeSlides.length);
                    
                    topMovies.forEach(movie => {
                        homeSlides.push({
                            id: movie.id,
                            title: movie.title,
                            type: movie.type,
                            image: movie.cover || movie.image,
                            url: `movies/${movie.id}`,
                            poster: movie
                        });
                    });
                }
                
                // Add top channels as slides if still not enough
                if (homeSlides.length < 5 && processedChannels.length > 0) {
                    const topChannels = processedChannels
                        .filter(c => c.rating > 7)
                        .sort((a, b) => b.rating - a.rating)
                        .slice(0, 5 - homeSlides.length);
                    
                    topChannels.forEach(channel => {
                        homeSlides.push({
                            id: channel.id,
                            title: channel.title,
                            type: 'channel',
                            image: channel.image,
                            url: `channels/${channel.id}`,
                            channel: channel
                        });
                    });
                }
                
                return {
                    api_info: updatedApiInfo,
                    home: {
                        slides: homeSlides,
                        featuredMovies: jsonData.home?.featured_movies || [],  // CamelCase for Java compatibility
                        channels: processedChannels,  // Move channels to home section
                        actors: jsonData.actors || [],  // Move actors to home section  
                        genres: jsonData.genres || []   // Move genres to home section
                    },
                    movies: processedMovies,
                    channels: processedChannels,  // Keep a copy at root for backward compatibility
                    actors: jsonData.actors || [],  // Keep a copy at root for backward compatibility
                    genres: jsonData.genres || []   // Keep a copy at root for backward compatibility
                };
            }
            
            function validateCineMaxAPI() {
                const results = document.getElementById('validationResults');
                results.style.display = 'block';
                
                const errors = [];
                const warnings = [];
                const info = [];
                
                // Check required sections
                if (!jsonData.api_info) errors.push('Missing api_info section');
                if (!jsonData.movies) errors.push('Missing movies array');
                if (!jsonData.channels) errors.push('Missing channels array');
                if (!jsonData.home) {
                    errors.push('Missing home section');
                } else {
                    // Check home section structure
                    if (!jsonData.home.slides) warnings.push('Missing home.slides array');
                    if (!jsonData.home.featuredMovies && !jsonData.home.featured_movies) warnings.push('Missing home.featuredMovies array');
                }
                if (!jsonData.actors) warnings.push('Missing actors array');
                if (!jsonData.genres) warnings.push('Missing genres array');
                
                // Check API info
                if (jsonData.api_info) {
                    if (!jsonData.api_info.version) warnings.push('Missing API version');
                    if (!jsonData.api_info.description) warnings.push('Missing API description');
                    if (!jsonData.api_info.last_updated) warnings.push('Missing last_updated date');
                }
                
                // Check movies structure
                if (jsonData.movies && jsonData.movies.length > 0) {
                    let movieCount = 0;
                    let seriesCount = 0;
                    
                    jsonData.movies.forEach((item, index) => {
                        if (!item.id) errors.push(`Item ${index + 1}: Missing id`);
                        if (!item.title) errors.push(`Item ${index + 1}: Missing title`);
                        
                        if (item.type === 'series') {
                            seriesCount++;
                            // For series, check if seasons/episodes have sources
                            if (!item.seasons || item.seasons.length === 0) {
                                warnings.push(`Series "${item.title}": No seasons defined`);
                            } else {
                                let hasEpisodeSources = false;
                                item.seasons.forEach(season => {
                                    if (season.episodes && season.episodes.length > 0) {
                                        season.episodes.forEach(episode => {
                                            if (episode.sources && episode.sources.length > 0) {
                                                hasEpisodeSources = true;
                                            }
                                        });
                                    }
                                });
                                if (!hasEpisodeSources) {
                                    warnings.push(`Series "${item.title}": No episode sources found`);
                                }
                            }
                        } else {
                            // For movies, check direct sources
                            movieCount++;
                            if (!item.sources || item.sources.length === 0) {
                                warnings.push(`Movie "${item.title}": No sources defined`);
                            }
                        }
                    });
                    
                    info.push(`${movieCount} movies and ${seriesCount} series validated`);
                } else {
                    warnings.push('No movies/series in API');
                }
                
                // Check channels structure
                if (jsonData.channels && jsonData.channels.length > 0) {
                    jsonData.channels.forEach((channel, index) => {
                        if (!channel.id) errors.push(`Channel ${index + 1}: Missing id`);
                        if (!channel.title) errors.push(`Channel ${index + 1}: Missing title`);
                        if (!channel.sources || channel.sources.length === 0) {
                            warnings.push(`Channel "${channel.title}": No sources defined`);
                        }
                    });
                    info.push(`${jsonData.channels.length} channels validated`);
                } else {
                    info.push('No channels in API');
                }
                
                // Generate report
                let report = '';
                let reportClass = 'success';
                
                if (errors.length > 0) {
                    reportClass = 'error';
                    report += `<strong>❌ ${errors.length} Error(s):</strong><br>`;
                    errors.forEach(error => report += `• ${error}<br>`);
                }
                
                if (warnings.length > 0) {
                    if (reportClass !== 'error') reportClass = 'warning';
                    report += `<strong>⚠️ ${warnings.length} Warning(s):</strong><br>`;
                    warnings.forEach(warning => report += `• ${warning}<br>`);
                }
                
                if (info.length > 0) {
                    report += `<strong>ℹ️ Info:</strong><br>`;
                    info.forEach(i => report += `• ${i}<br>`);
                }
                
                if (errors.length === 0 && warnings.length === 0) {
                    report = '<strong>✅ API validation passed!</strong><br>Your CineMax API is ready for use.';
                    reportClass = 'success';
                }
                
                results.innerHTML = report;
                results.style.backgroundColor = reportClass === 'error' ? '#ffebee' : 
                                                reportClass === 'warning' ? '#fff3e0' : '#e8f5e8';
                results.style.color = reportClass === 'error' ? '#c62828' : 
                                     reportClass === 'warning' ? '#ef6c00' : '#2e7d32';
                results.style.border = `1px solid ${reportClass === 'error' ? '#c62828' : 
                                                   reportClass === 'warning' ? '#ef6c00' : '#2e7d32'}`;
                
                showNotification(`Validation completed: ${errors.length} errors, ${warnings.length} warnings`, 
                               errors.length === 0);
            }
            
            // --- Info Toggle Function ---
            window.toggleInfo = function() {
                const content = document.getElementById('infoContent');
                const chevron = document.getElementById('infoChevron');
                
                if (content.classList.contains('show')) {
                    content.classList.remove('show');
                    chevron.className = 'fas fa-chevron-down';
                } else {
                    content.classList.add('show');
                    chevron.className = 'fas fa-chevron-up';
                }
            };

            // --- Event Listeners ---
            closeModalButton.addEventListener('click', closeModal);
            window.addEventListener('click', (event) => {
                if (event.target === modal) {
                    closeModal();
                }
            });
            
            // --- Auto-Load on Page Start ---
            console.log('🔄 Checking for auto-saved data...');
            if (autoSaveEnabled) {
                const hasRestored = loadFromLocalStorage();
                if (hasRestored) {
                    console.log('✅ Auto-saved data restored successfully');
                } else {
                    console.log('ℹ️ No auto-saved data found');
                }
            } else {
                console.log('⏸️ Auto-save disabled, skipping auto-load');
            }
        });
    </script>
</body>
</html>